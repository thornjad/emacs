# -*- lexical-binding: t; -*-
#+title: Thornjad's Emacs Configuration
#+author: Jade Michael Thornton <thornjad>
#+link: https://emacs.jmthornton.net
#+html_link_home: https://jmthornton.net
#+html_link_up: https://github.com/thornjad/emacs
#+description: Here lives Thornjad's Emacs configuration. There are many like it, but this one is mine.
#+filetags: :emacs:
#+startup: overview
#+options: num:nil toc:t html-postamble:nil html-html5-fancy:t
#+property: header-args:emacs-lisp :tangle yes :lexical t :results silent :exports code :eval never-export
#+export_file_name: index.html
#+html_doctype: html5
#+html_head: <link rel="stylesheet" href="static/styles.css" type="text/css" />
#+html_head: <script src="/static/script.js"></script>

#+begin_export html
<button onclick="toggleTOC()">Toggle Table of Contents</button>
#+end_export

* Introduction
Here lives my own configuration for GNU Emacs, blending all the best shit I can find, making a conscious effort for speed, robustness and above all, skillfulness. There are many like it, but this one is mine.

#+begin_quote
"Configuring Emacs is more of a lifestyle choice than a task that one completes." — Stephen Ramsey
#+end_quote

This is most definitely not a general distribution Emacs configuration system. It undergoes constant evolution; bindings, settings and packages change with no warning and little to no documentation. This project is open source as a reference or source of ideas. Use at your own risk.

To get started with Emacs, I highly recommend the distribution responsible for hooking me in: [[https://spacemacs.org][Spacemacs]].

#+begin_quote
"An infinite number of monkeys typing into GNU Emacs would never make a good program." — Linus Torvalds
#+end_quote

When I first started using Emacs, I took full advantage of Spacemacs, so the architecture of that project has shaped the way I think about editing. As such, the majority of the config revolves around a single leader key, =SPC=. For example, =SPC SPC= is the same as =M-x=, =SPC f w= (for file write) saves the buffer to disk.

For everything else, this config makes extensive use of [[https://github.com/emacs-evil/evil][Evil]], providing the user with modifier-key-free modal editing, though the majority of Emacs bindings remain available. Emacs keybindings belong in the dark ages where they originated. They might work for RMS, but I can only hold =CTRL= for so long.

My config uses my =aero-theme=, which pulls loose inspiration from the [[https://github.com/11111000000/tao-theme-emacs][Tao themes]] and colors inspired by northern Minnesota in Autumn. The theme package also contains =aero-dark=, which incorporates further inspiration from my own [[https://github.com/ClearNight/clearnight-retro-syntax][ClearNight Retro]] theme for [[https://atom.io][Atom]] (may it rest in peace).

Within this config, you'll also find a custom improved mode line which works with any theme (though it looks great with =aero-light= and =aero-dark=). Rather than getting cluttered with info from every mode under the sun, the Aero mode line displays the current editing mode, file status (changed, saved, locked), filename, file size, line number at point, progression through the file (percentage), the remote hostname (if using TRAMP) and the current major mode.

** Installation
Clone this repo into your =~/.config/emacs= and run =make init=. The make command will install dependencies needed for LSP servers, using any tools already available on the system (e.g. it will not error if =opam= isn't installed), as well as dependencies like =graphviz= and =lsp-booster=. It will also set up and update some submodules.

Upon starting up Emacs for the first time, further third-party packages will automatically download and install via =straight.el=. Subsequent startups should take one or two seconds. If you encounter any errors at this stage, try restarting Emacs and/or opening a bug.

*** Emacs installation using included build scripts
My configuration includes some convenient scripting to install Emacs on Linux and Mac, with both a stable and cutting-edge version supported for Mac.

**** Installing Emacs on Linux
The =make linux= target will call =linux.zsh=, which installs requirements, configures, builds and installs the latest version of Emacs.

**** Installing Emacs on MacOS
Unlike Linux, installing and running Emacs on MacOS can be flaky, so several installation options are provided. Use the one that works best on your machine.

- =make build-emacs-macos=: This is the preferred option, installing the development version of Emacs with native compilation and XWidgets support.
- =make build-emacs-macos-stable=: A fallback option, installing the mainline release version of Emacs, with native compilation and XWidgets support.
- =make build-emacs-macos-minimal=: Same as =build-emacs-macos= but without native compilation.
- =make build-emacs-macos-stable-minimal=: Same as =build-emacs-macos-stable= but without native compilation.
- =make build-emacs-cask=: Install the standard Homebrew Cask =emacs-nightly= package, still cutting-edge but should be more stable than the previous options.
- =make build-emacs-cask-stable=: The final fallback, the standard Homebrew Cask =emacs= package.

** Local configuration
Your environment may require specific configuration, such as secret keys, environment variables, or work-specific functions, which should not appear in a git repository. My config features the ability to read an =init.local.el= when it exists in the same directory as the =init.el=. This local file may contain arbitrary Elisp, which is executed after everything else.

** Credits and acknowledgements
Like the Borg, my config amalgamates macros, functions, bindings and packages modified from or inspired by a plethora of developers. Special thanks to these fantastic people, with links to the invaluable resource they provide:

- [[https://github.com/sachac/.emacs.d][Sacha Chua]]
- [[https://svn.red-bean.com/repos/kfogel/trunk/.emacs][Karl Fogel]]
- [[https://github.com/Wilfred/.emacs.d][Wilfred Hughes]]
- [[https://github.com/jwiegley/dot-emacs][John Wiegley]]
- [[https://github.com/purcell/emacs.d][Steve Purcell]]
- [[https://github.com/sam217pa/emacs-config][Samuel Barreto]]

** Copyright Notice
Copyright (c) 2016-2025 Jade Michael Thornton

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

The software is provided "as is" and the author disclaims all warranties with
regard to this software including all implied warranties of merchantability
and fitness. In no event shall the author be liable for any special, direct,
indirect, or consequential damages or any damages whatsoever resulting from
loss of use, data or profits, whether in an action of contract, negligence or
other tortious action, arising out of or in connection with the use or
performance of this software.

* How this file is loaded
Obviously you're reading an org file right now, not Emacs Lisp, so =org-babel= converts (tangles) all the source block in this file into a =config.el= file, which is then actually executed to configure Emacs.

This conversion kicks off from =init.el=, which also sets up some critical early functionality such as determining if treesitter is available and messing with garbage collection (a controversial practice). Then =org-babel-load-file= is called on this org file and whole configuration journey is launched. The rest of this file is executed in order, with everything that is not inside a source block stripped out.

*** Tips
When inside of an Org source block, you can use =org-babel-demarcate-block= to split the block you're currently in so that you can insert an annotation.

* Lexical binding
Before any other code, we have to make sure the tangled =config.el= has lexical binding, or else we're in for a world of pain. I cannot understand why this isn't the default. Emacs should at least have an option to make everything lexical by default, forcing old code to opt-out.

#+BEGIN_SRC emacs-lisp :lexical t
  ;;; -*- lexical-binding: t -*-
#+END_SRC

* Directory constants
These define some locations that we can reference later

#+BEGIN_SRC emacs-lisp :lexical t
  (defconst aero-lib-dir (expand-file-name "lib/" user-emacs-directory))
  (defconst aero-etc-dir (expand-file-name "etc/" user-emacs-directory))
  (defconst aero-snippets-dir (expand-file-name "snippets/" user-emacs-directory))
  (defconst aero-cache-dir (expand-file-name "cache/" aero-etc-dir))
  (defconst pcache-directory (expand-file-name "pcache/" aero-cache-dir))
  (unless (file-exists-p aero-cache-dir) (make-directory aero-cache-dir))
#+END_SRC

We also need to set up locations for org-roam and thornlog. Thornlog is a custom daily logging and note-taking system, using org-roam. Check out the [[Thornlog]] section for more.

#+BEGIN_SRC emacs-lisp :lexical t
  (defconst aero/documents-path (expand-file-name "~/Documents/"))
  (defconst aero/thornlog-path (expand-file-name "thornlog/" aero/documents-path))
  (defconst aero/roam-path (expand-file-name "roam/" aero/thornlog-path))
  (defconst aero/thornlog-archive-file (expand-file-name "archive/archive.org" aero/thornlog-path))
  (defconst aero/thornlog-elfeed-directory (expand-file-name "elfeed/" aero/documents-path)
    "The directory where elfeed will store its database and other files.")
  (defconst aero/thornlog-elfeed-org-file (expand-file-name "rss_feeds.org" aero/roam-path))
#+END_SRC

* Builtin requires
#+BEGIN_SRC emacs-lisp :lexical t
  (require 'cl-lib)
  (require 'subr-x)
  (require 'imenu)
#+END_SRC

These are mostly used by Org, not sure if they're still needed.

#+BEGIN_SRC emacs-lisp :lexical t
  (require 'outline)
  (require 'notifications)
#+END_SRC

* Define Library functions
** Advice
Also kill excess whitespace when joining lines.

#+BEGIN_SRC emacs-lisp :lexical t
  (defadvice kill-line (before kill-line-autoreindent activate)
    "Kill excess whitespace when joining lines.
  If the next line is joined to the current line, kill the extra indent whitespace in front of the next line."
    (when (and (eolp) (not (bolp)))
      (save-excursion
        (forward-char 1)
        (just-one-space 1))))
#+END_SRC

When getting symbol documentation in Elisp, also append its docstring.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/advice-elisp-get-fnsym-args-string (fn sym &rest args)
    "If SYM is a function, append its docstring."
    (concat
     (apply fn sym args)
     (let ((doc (and (fboundp sym) (documentation sym 'raw))))
       (and doc
            (stringp doc)
            (not (string= "" doc))
            (concat "\n\n" (propertize doc 'face 'italic))))))
  (advice-add 'elisp-get-fnsym-args-string :around #'aero/advice-elisp-get-fnsym-args-string)
#+END_SRC

When indenting a new line inside a comment, add at least one space at the start.

#+BEGIN_SRC emacs-lisp :lexical t
  (define-advice comment-indent-new-line (:after (&optional soft) at-least-one-space)
    "Ensure that at least one space is added after the comment-start."
    (let ((start (regexp-quote comment-start)))
      (when (and (nth 4 (syntax-ppss))
                 (looking-back start (+ (point) (length start)))
                 (not (looking-back " "  (+ (point) 1))))
        (insert " "))))
#+END_SRC

Don't kill the main scratch buffer, only bury it.

#+BEGIN_SRC emacs-lisp :lexical t
  (defadvice kill-buffer (around kill-buffer-around-advice activate)
    "Don't kill my scratch!"
    (let ((buffer-to-kill (ad-get-arg 0)))
      (if (equal buffer-to-kill "*scratch*")
          (bury-buffer)
        ad-do-it)))
#+END_SRC

** Utilities
#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/keyboard-quit-context ()
    "Quit current context.

  This function is a combination of `keyboard-quit' and `keyboard-escape-quit'
  with some parts omitted and some custom behavior added."
    ;; Adapted from https://with-emacs.com/posts/tips/quit-current-context/
    (interactive)
    (cond
     ((region-active-p)
      ;; Avoid adding the region to the window selection.
      (setq saved-region-selection nil)
      (let (select-active-regions)
        (deactivate-mark)))

     ((eq last-command 'mode-exited)
      nil)

     (current-prefix-arg
      nil)

     (defining-kbd-macro
       (message
        (substitute-command-keys
         "Quit is ignored during macro defintion, use \\[kmacro-end-macro] if you want to stop macro definition"))
       (cancel-kbd-macro-events))

     ((active-minibuffer-window)
      (when (get-buffer-window "*Completions*")
        ;; hide completions first so point stays in active window when
        ;; outside the minibuffer
        (minibuffer-hide-completions))
      (abort-recursive-edit))

     (t
      (keyboard-quit))))

  (defun aero/comment-dwim ()
    "Comment region if active, else comment line.

  This avoids the excess region commenting of `comment-line' while also avoiding the weird single-line
  behavior of `comment-dwim'."
    (interactive)
    (save-excursion
      (if (use-region-p)
          (call-interactively #'comment-or-uncomment-region)
        (call-interactively #'comment-line))))

  (defmacro aero/voidvar! (&rest body)
    "Appease the compiler by pretending to use variables in BODY.

  Similar to C++'s void var construct."
    `(and ,@body))
#+END_SRC

** System and logging
#+BEGIN_SRC emacs-lisp :lexical t
  (defun system-is-mac () (string= system-type 'darwin))
  (defun system-is-linux () (string= system-type 'gnu/linux))
  (defun system-is-mswindows () (string= system-type 'windows-nt))
  (defun window-system-is-mac () (memq (window-system) '(mac ns)))
  (defun in-nix-shell-p () (string-equal (getenv "IN_NIX_SHELL") "1"))

  (defun aero/has-modules-p ()
    "Return true when Emacs has been compiled with modules support."
    (and (functionp 'module-load) (bound-and-true-p module-file-suffix)))

  (defun treesitterp ()
    "Evaluate whether Emacs has treesitter support."
    (and (functionp 'treesit-available-p) (treesit-available-p)))
#+END_SRC

*** Change font size (zoom in and out)
Especially useful when screen sharing, Google Meet in particular really makes things blurry.

Based on https://sachachua.com/blog/2006/09/emacs-changing-the-font-size-on-the-fly/

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/increase-font-size ()
    (interactive)
    (set-face-attribute 'default nil :height (ceiling (* 1.10 (face-attribute 'default :height)))))
  (defun aero/decrease-font-size ()
    (interactive)
    (set-face-attribute 'default nil :height (floor (* 0.9 (face-attribute 'default :height)))))
  (global-set-key (kbd "C-+") 'aero/increase-font-size)
  (global-set-key (kbd "C--") 'aero/decrease-font-size)
#+END_SRC

Also allow =C-==, just to be less annoying since that's just + without shift

#+BEGIN_SRC emacs-lisp :lexical t
  (global-set-key (kbd "C-=") 'aero/increase-font-size)
#+END_SRC

** Buffers, windows, frames, tabs
A collection of helpers for managing windows and buffers

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/switch-to-minibuffer-window ()
    "switch to minibuffer window (if active)"
    (interactive)
    (when (active-minibuffer-window)
      (select-window (active-minibuffer-window))))

  (defun switch-to-messages-buffer ()
    (interactive)
    (switch-to-buffer "*Messages*"))

  (defun switch-to-scratch-buffer ()
    (interactive)
    (switch-to-buffer "*scratch*"))

  (defun switch-to-new-scratch-buffer ()
    (interactive)
    (switch-to-buffer (generate-new-buffer "*scratch*")))

  (defun aero/bury-buffer-kill-window (&optional window)
    "Bury the current buffer and kill its window, or use WINDOW."
    (interactive)
    (let* ((buf (window-buffer window))
           (win (get-buffer-window buf)))
      (bury-buffer buf)
      (delete-window win)))

  (defun aero/alternate-buffer (&optional window)
    "Switch back and forth between current and last buffer in the current window."
    (interactive)
    (cl-destructuring-bind
        (buf start pos)
        (or (cl-find (window-buffer window) (window-prev-buffers) :key #'car :test-not #'eq)
            (list (other-buffer) nil nil))
      (if (not buf)
          (message "Last buffer not found")
        (set-window-buffer-start-and-point window buf start pos))))

  (defun aero/alternate-window ()
    "Switch back and forth between current and last window in the current frame."
    (interactive)
    (let ( ;; switch to first window previously shown in this frame
          (prev-window (get-mru-window nil t t)))
      ;; Check window was not found successfully
      (unless prev-window
        (user-error "Last window not found."))
      (select-window prev-window)))

  (defun aero/tail-compilation-buffer ()
    "Reset tailing the compilation buffer."
    (interactive)
    (let* ((buf-name (aero/get-compilation-buffer-name))
           (window (get-buffer-window buf-name))
           (pos (with-current-buffer buf-name (point-max))))
      (set-window-point window pos)))

  (defun aero/project-compile-popup ()
    "Run `project-compile' and pop up the compilation buffer."
    (interactive)
    (let ((buf (get-buffer-create (aero/get-compilation-buffer-name))))
      (aero/toggle-compilation-buffer)
      (project-compile)
      (aero/tail-compilation-buffer)))

  (defun aero/get-compilation-buffer-name ()
    "Return the compilation buffer name for the current project."
    (if (project-current nil)
        (project-prefixed-buffer-name "compilation")
      "*compilation*"))

  (defun aero/toggle-compilation-buffer ()
    "Pop-up the compilation buffer."
    (interactive)
    (aero/toggle-popup-buffer (aero/get-compilation-buffer-name))
    (aero/tail-compilation-buffer))

  (defun aero/toggle-popup-buffer (buf)
    "Pop-up BUF in a buffer below."
    (let ((win (get-buffer-window buf 0)))
      (if win
          ;; found, so close it
          (aero/bury-buffer-kill-window win)

        ;; else we need to pop it up
        (progn
          (display-buffer buf
                          '((display-buffer-below-selected)
                            (reusable-frames . nil) ;; only search this frame
                            (window-height . 20)))
          (set-window-dedicated-p (get-buffer-window buf) t)))))

  (defun aero/incr-compilation-buffer ()
    "Renames existing compilation buffer so you can create more."
    (interactive)
    (let ((cbuf (get-buffer "*compilation*"))
          (more-cbufs t)
          (n 1)
          (new-cbuf-name ""))
      (when cbuf
        (while more-cbufs
          (setq new-cbuf-name (format "*compilation%d*" n))
          (setq n (1+ n))
          (setq more-cbufs (get-buffer new-cbuf-name)))
        (with-current-buffer cbuf
          (rename-buffer new-cbuf-name)))))

  (defun aero/eshell-new ()
    "Open a new Eshell window."
    (interactive)
    (eshell t))

  (defun aero/project-eshell-new ()
    "Open a new project Eshell."
    (interactive)
    (let ((current-prefix-arg t))
      (project-eshell)))

  (defmacro aero/async-shell-command-with-path (command &optional buffer error-buffer)
    "Run COMMAND asynchronously like `async-shell-command' but with PATH loaded."
    `(let ((shell-command-switch "-ic"))
       (async-shell-command ,command ,buffer ,error-buffer)))
#+END_SRC

** Files
*** Reopen file at buffer
It's occasionally useful to "restart" the current buffer. To my current knowledge this isn't a builtin functionality, so I have my own function.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/reopen-file-at-buffer ()
    "Re-open the file at buffer, replacing buffer.

  After reopening, cursor will attempt to return to the point it was previously
  on. This may cause a jump if the file has changed significantly. Finally, the
  buffer will be recentered to the line at point."
    (interactive)
    (let ((initial-line (line-beginning-position))
          (initial-point (point))
          (initial-total-lines (count-lines (point-min) (point-max))))
      (find-alternate-file (buffer-file-name))
      (if (= initial-total-lines (count-lines (point-min) (point-max)))
          ;; If total lines have not changed, we can reasonably guess that the
          ;; content has not changed significantly (if at all), so we can jump
          ;; right back to the initial point.
          (goto-char initial-point)
        ;; If total lines /have/ changed, we can reasonably guess that the initial
        ;; point is contextually not where we were before. The best thing we can
        ;; do now is return to the same line number, and hope it's close. Getting
        ;; closer than this would require text parsing, which is more complex than
        ;; we need for a simple file replacement.
        (goto-char initial-line))
      ;; Finally, recenter the line. We may not have been centered before, but this is more often than
      ;; not what we want.
      (recenter)))
#+END_SRC

*** Other file helpers

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/insert-org-date ()
    "Insert current date."
    (interactive)
    (insert (format-time-string "[%Y-%m-%d]")))
  (defun aero/insert-timestamp ()
    "Insert current timestamp."
    (interactive)
    (insert (format-time-string "%Y-%m-%dT%H:%M:%S")))
  (defun aero/insert-org-timestamp ()
    (interactive)
    (insert (format-time-string "[%Y-%m-%dT%H:%M:%S]")))

  (defun aero/insert-unix-time-seconds ()
    "Insert current Unix timestamp."
    (interactive)
    (insert (format-time-string "%s")))
  (defun aero/insert-unix-time-milliseconds ()
    "Insert current Unix timestamp."
    (interactive)
    (insert (number-to-string (truncate (* 1000 (float-time))))))

  (defun aero/filename-relative-to-project ()
    "Return the path of the current buffer relative to the project root."
    (file-relative-name (buffer-file-name) (project-root (project-current))))

  (defun aero/copy-file-relative-to-project ()
    "Copy the path of current buffer relative to the project."
    (interactive)
    (kill-new (aero/filename-relative-to-project)))

  (defun aero/delete-this-file ()
    "Delete the current file, and kill the buffer."
    (interactive)
    (or (buffer-file-name) (error "No file is currently being edited"))
    (when (yes-or-no-p (format "Really delete '%s'?" (file-name-nondirectory buffer-file-name)))
      (delete-file (buffer-file-name))
      (kill-this-buffer)))

  (defun aero/rename-this-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (unless filename
        (error "Buffer '%s' is not visiting a file!" name))
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (progn
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)))))

  (defun aero/fill-to-80 ()
    "`fill-paragraph' to 80 columns, regardless of the default."
    (interactive)
    (let ((fill-column 80))
      (fill-paragraph)))

  (defun aero/dos2unix ()
    "Converts the current buffer to UNIX file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-unix nil))
  (defun aero/unix2dos ()
    "Converts the current buffer to DOS file format."
    (interactive)
    (set-buffer-file-coding-system 'undecided-dos nil))

  (declare-function tramp-cleanup-all-connections "tramp.el")
  (defun aero/tramp-buffer-p (buffer)
    (let ((name (buffer-name buffer)))
      (string-match "^\\*tramp" name)))
  (defun aero/kill-tramp ()
    "Kill all Tramp connections. Useful for stale connections.
    This function does NOT remove remote buffers, only their connections."
    (interactive)
    (when (require 'tramp nil t)
      (declare-function password-reset "password-cache.el")
      (password-reset)
      (cancel-function-timers 'tramp-timeout-session)
      (declare-function tramp-list-tramp-buffers "tramp.el")
      (dolist (name (tramp-list-tramp-buffers))
        (when (processp (get-buffer-process name))
          (delete-process name)))))

  (defun aero/kill-tags ()
    "Kill the currently-loaded TAGS file."
    (interactive)
    (when (get-buffer "TAGS")
      (kill-buffer "TAGS")))

  (defun aero/open-emacs-problems ()
    "Open Emacs PROBLEMS file from GitHub mirror."
    (interactive)
    (eww "https://github.com/emacs-mirror/emacs/blob/master/etc/PROBLEMS"))

  (defun aero/xdg-open (arg)
    "Pass the specified ARG to \"xdg-open\".

    This can be used to open Nautilus/Finder, the default browser, etc. See \"man
    xdg-open\" for more."
    (interactive (list (read-string "Open: ")))
    (let ((proc
           (cond
            ((system-is-linux)
             "xdg-open")
            ((system-is-mac)
             "open")
            (t
             (user-error "No system process to use on this OS")))))
      (call-process proc nil 0 nil arg)))

  (defun aero/browse-url-open (url &optional _ignored)
    "Pass the specified URL to `aero/xdg-open'.

    Ignored arg is due to the way `funcall-interactively' calls stuff."
    (interactive
     (let ((link (and (derived-mode-p 'org-mode)
                      (org-element-context))))
       (if (and link (eq (car link) 'link))
           (list (org-element-property :raw-link link))
         (browse-url-interactive-arg "URL: "))))
    (aero/xdg-open url))
#+END_SRC

** Et cetera
#+BEGIN_SRC emacs-lisp :lexical t
  ;; written by github user rompy
  (defun aero/smarter-backward-kill-word ()
    "Deletes the previous word, respecting:
  1. If the cursor is at the beginning of line, delete the '\n'.
  2. If there is only whitespace, delete only to beginning of line.
  3. If there is whitespace, delete whitespace and check 4-5.
  4. If there are other characters instead of words, delete one only char.
  5. If it's a word at point, delete it."
    (interactive)
    (if (bolp)
        (delete-char -1)
      (if (string-match-p
           "^[[:space:]]+$" (buffer-substring-no-properties (line-beginning-position) (point)))
          (delete-horizontal-space)
        (when (thing-at-point 'whitespace)
          (delete-horizontal-space))
        (if (thing-at-point 'word)
            (let ((start (car (bounds-of-thing-at-point 'word)))
                  (end (point)))
              (if (> end start)
                  (delete-region start end)
                (delete-char -1)))
          (delete-char -1)))))

  (defun untabify-buffer ()
    (interactive)
    (untabify (point-min) (point-max)))
  (defun tabify-buffer ()
    (interactive)
    (tabify (point-min) (point-max)))
  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun alter-number-at-point (offset)
    (save-excursion
      (skip-chars-backward "0-9")
      (or (looking-at "[0-9]+") (message "No number at point"))
      (replace-match (number-to-string (+ offset (string-to-number (match-string 0)))))))
  (defun increment-number-at-point ()
    (interactive)
    (alter-number-at-point 1))
  (defun decrement-number-at-point ()
    (interactive)
    (alter-number-at-point -1))

  (defun human-date (human-string &optional epoch)
    "Convert HUMAN-STRING to a date string or if EPOCH, seconds.
  Requires the utility date to be installed."
    (with-temp-buffer
      (let ((dateProc
             (if (system-is-mac)
                 "gdate"
               "date")))
        (if epoch
            (call-process dateProc nil t nil "-d" human-string "+%s")
          (call-process dateProc nil t nil "-d" human-string)))
      (replace-regexp-in-string "\n\\'" "" (buffer-string))))

  (defun day-of-week ()
    "Return the current day of the week."
    (format-time-string "%A"))

  (defun day-after (day-name)
    "Return the name of the day following the day given by 'day-name'."
    (format-time-string "%A" (time-add (date-to-time (concat day-name " 00:00")) (* 24 60 60))))

  (defun aero/frame-recenter (&optional frame)
    "Center FRAME on the screen.

  FRAME can specify a frame name, a terminal name, or a frame.
  If FRAME is omitted or nil, use currently selected frame."
    (interactive)
    (unless (eq 'maximised (frame-parameter nil 'fullscreen))
      (let* ((frame (or (and (boundp 'frame) frame) (selected-frame)))
             (frame-w (frame-pixel-width frame))
             (frame-h (frame-pixel-height frame))
             (display (frame-parameter frame 'display))
             (monitor-w (display-pixel-width display))
             (monitor-h (display-pixel-height display))
             ;; NS doesn't report menu bar as outside monitor
             (monitor-h
              (if (eq window-system 'ns)
                  (- monitor-h 22)
                monitor-h))
             (center (list (/ (- monitor-w frame-w) 2) (/ (- monitor-h frame-h) 2))))
        (apply 'set-frame-position (flatten-list (list frame center))))))

  (defun aero/ssh-refresh ()
    "Reset the environment variable SSH_AUTH_SOCK"
    (interactive)
    (let (ssh-auth-sock-old
          (getenv "SSH_AUTH_SOCK"))
      (setenv "SSH_AUTH_SOCK"
              (car
               (split-string
                (shell-command-to-string
                 "ls -t $(find /tmp/ssh-* -user $USER -name 'agent.*' 2> /dev/null)"))))
      (message (format "SSH_AUTH_SOCK %s --> %s" ssh-auth-sock-old (getenv "SSH_AUTH_SOCK")))))

  (defun aero/unix-timestamp-to-human (timestamp)
    "Convert a UNIX TIMESTAMP to a human-readable string."
    (interactive (list (read-string "Timestamp: " (thing-at-point 'word))))
    ;; convert from milliseconds if it looks like milliseconds
    (let ((timestamp (if (>= (string-to-number timestamp) 10000000000)
                         (/ (string-to-number timestamp) 1000)
                       (string-to-number timestamp))))
      (message (format-time-string "%Y-%m-%d %H:%M:%S" (seconds-to-time timestamp)))))

  (defun aero/toggle-angular-component-file ()
    "Toggle between an Angular component's Typescript and HTML files."
    (interactive)
    (let ((current-file buffer-file-name))
      (when current-file
        (let* ((file-ext (file-name-extension current-file))
               (base-name (file-name-sans-extension current-file))
               (toggle-ext (cond ((string-equal file-ext "html") "ts")
                                 ((string-equal file-ext "ts") "html")
                                 (t nil)))
               (prefered-filename
                (concat base-name
                        (when (string-equal toggle-ext "ts")
                          ".component")
                        "." toggle-ext)))
          (if (and prefered-filename (file-exists-p prefered-filename))
              (find-file prefered-filename)
            (let ((alternative-filename (concat base-name "." toggle-ext)))
              (if (and toggle-ext (file-exists-p alternative-filename))
                  (find-file alternative-filename)
                (message "No corresponding file found for %s" current-file))))))))

  (defun aero/org-convert-region-from-markdown (beg end)
    (interactive "r")
    (shell-command-on-region beg end "pandoc -t org" nil t))

  (defun aero/open-emacs-config ()
    "Open an org-agenda file from a list of all agenda files."
    (interactive)
    (find-file (expand-file-name "config.org" user-emacs-directory)))

  (defun aero/eslint-fix-file ()
    "Run eslint --fix on the current buffer's file."
    (interactive)

    (when (buffer-modified-p)
      (if (y-or-n-p (format "Save file %s? " buffer-file-name))
          (save-buffer)
        (user-error "ESLint refusing to run on a modified buffer")))

    (message "Running ESLint fix...")

    (let* ((default-directory (project-root (project-current)))
           (filename (aero/filename-relative-to-project))
           (error-buffer (get-buffer-create "*ESLint Fix Errors*"))
           (exit-code (call-process "npx" nil error-buffer nil
                                    "eslint" "--fix" buffer-file-name)))
      (if (zerop exit-code)
          (progn
            (message "ESLint fix complete")
            (revert-buffer t t t))
        (message "ESLint fix failed with error code %d" exit-code)
        (pop-to-buffer error-buffer))))

  (defun aero/prettier-fix-file ()
    "Run prettier --write on the current buffer's file."
    (interactive)
    (when (buffer-modified-p)
      (if (y-or-n-p (format "Save file %s? " buffer-file-name))
          (save-buffer)
        (user-error "Prettier refusing to run on a modified buffer")))
    (message "Running Prettier fix...")
    (let* ((default-directory (project-root (project-current)))
           (filename (aero/filename-relative-to-project))
           (error-buffer (get-buffer-create "*Prettier Fix Errors*"))
           (exit-code (call-process "npx" nil error-buffer nil
                                    "prettier" "--write" buffer-file-name)))
      (if (zerop exit-code)
          (progn
            (message "Prettier fix complete")
            (revert-buffer t t t))
        (message "Prettier fix failed with error code %d" exit-code)
        (pop-to-buffer error-buffer))))
#+END_SRC

* Packaging setup
** GnuTLS
Evaluate =gnutls= and disallow TLS connections

#+BEGIN_SRC emacs-lisp :lexical t
  (with-eval-after-load 'gnutls
    (eval-when-compile (require 'gnutls))
    (setq gnutls-verify-error t)) ; Do not allow insecure TLS connections.
#+END_SRC

** Straight.el
We want to use the =develop= branch of =straight.el=, since it tends to be better.

#+BEGIN_SRC emacs-lisp :lexical t
  ;; Use the more-cutting-edge develop branch of straight
  (eval-when-compile
    (defvar straight-repository-branch)
    (defvar straight-check-for-modifications))
  (setq straight-repository-branch "develop")
#+END_SRC

Don't allow straight to check for modifications in every repo on Emacs init, saving some startup time

#+BEGIN_SRC emacs-lisp :lexical t
  (setq straight-check-for-modifications nil)
#+END_SRC

Set the order in which repositories are checked for =:auto= recipes. These are based on broad levels of trust, if something appears in both GNU ELPA and MELPA, for example, we'd prefer the GNU ELPA version. Also prefer using the mirror of GNU ELPA because it's stupidly more efficient than the normal GNU ELPA build process.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq straight-recipe-repositories
        '(org-elpa gnu-elpa-mirror nongnu-elpa emacsmirror-mirror melpa))
  (setq straight-recipes-gnu-elpa-use-mirror t)
#+END_SRC

Tell straight that let-alist is a built-in package now, so it doesn't need to be checked if we (or more likely any dependency) try to pull it in.

#+BEGIN_SRC emacs-lisp :lexical t
  (with-eval-after-load 'straight
    (add-to-list 'straight-built-in-pseudo-packages 'let-alist))
#+END_SRC

Bootstrapping for =straight.el=

#+BEGIN_SRC emacs-lisp :lexical t
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/radian-software/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))
#+END_SRC

I'm not certain straight needs to be set up before use-package, but before use-package was built in to Emacs something got messed up when use-package was loaded first.

#+BEGIN_SRC emacs-lisp :lexical t
  (require 'use-package)
#+END_SRC

If we're byte-compiling something, only expand minimally

#+BEGIN_SRC emacs-lisp :lexical t
  (eval-when-compile
    (defvar use-package-expand-minimally)
    (defvar use-package-compute-statistics)
    (defvar use-package-minimum-reported-time)
    (defvar use-package-verbose))
  (setq use-package-expand-minimally byte-compile-current-file
        use-package-compute-statistics nil ; t then `use-package-report' to find packages not used
        package-native-compile t ; compile when installing (not sure if this works)
        use-package-minimum-reported-time 0.1)
#+END_SRC

If we're using =--debug-init=, make package loading verbose.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq use-package-verbose init-file-debug)
#+END_SRC

** Custom package macro
The rest of the config uses this custom =package!= macro to abstract away some internals that have changed in the past and may change again (such as using =straight.el=).

#+BEGIN_SRC emacs-lisp :lexical t
  (defmacro package! (package recipe &rest body)
    "Get PACKAGE using RECIPE, then evaluate PACKAGE & BODY with `use-package'.

  Example:

      (package! foo (:host gitlab :repo \"thornjad/foo\" :branch \"main\")
       :commands (foo-bar foo-spam))

  If the RECIPE is :builtin or :local, do not search [M]ELPA, only pass BODY to `use-package'. While
  there is no functional difference between these two keywords, :builtin should be used for packages
  within Emacs while :local should be used for user packages which exist locally. :local packages may
  require a :load-path for `use-package' to load properly.

  If the BODY contains the keyword :disabled, the package is completely ignored, with an expansion
  indicating the package has been disabled.

  If the recipe does not contain a :host, it default to 'github.

  If the recipe is only a string, it is considered a github repo.

  Usage of this macro allows simplified refactoring when changing packaging systems, as Aero is wont
  to do every few years."
    (declare (indent defun)) ; indent like use-package

    (when (stringp recipe)
      (setq recipe (list :repo recipe)))

    (cond
     ((memq :disabled body)
      (format "%s :disabled by Aero package!" package))

     ((equal recipe :builtin)
      `(use-package ,package :straight (:type built-in) ,@body))

     ((equal recipe :local)
      `(use-package ,package :straight nil ,@body))

     ((equal recipe :localpackage)
      `(use-package ,package :straight nil :load-path "lib/localpackages" ,@body))

     ;; Use straight
     (t
      (progn
        (when (and (not (equal recipe :auto))
                   (and (not (memq :host recipe))
                        (not (memq :source recipe))))
          (setq recipe (plist-put recipe :host 'github)))

        `(use-package ,package :straight ,(or (equal recipe :auto) recipe) ,@body)))))

#+END_SRC

* Core setup (prelude)
I use "prelude" here as a nod to earlier iterations of this configuration, where the core setup lived in a prelude file, meaning it was required to setup important functionality. The name is only tangentially related to the Prelude configuration distribution, the two usages are cognate.

** Treesitter initialization
To ensure we can use this easily later, require treesitter as long as it's available and wanted. See [[*Treesitter][Treesitter]] section for the full config.

#+BEGIN_SRC emacs-lisp :lexical t
  (and (and (treesitterp)
            (functionp 'module-load)
            (bound-and-true-p module-file-suffix))
       (require 'treesit nil t))
#+END_SRC

** Compile angel
Set up automatic compilation for everything past this point

#+BEGIN_SRC emacs-lisp :lexical t
  (package! compile-angel "jamescherti/compile-angel.el"
    :demand t
    :hook (emacs-lisp-mode-hook . compile-angel-on-save-local-mode)

    :custom
    (compile-angel-verbose t)
    (compile-angel-enable-byte-compile nil) ; only native compile

    :config
    ;; Exclude these files
    (with-eval-after-load "savehist" (push (concat "/" (file-name-nondirectory savehist-file))
                                           compile-angel-excluded-files))
    (with-eval-after-load "recentf" (push (concat "/" (file-name-nondirectory recentf-save-file))
                                          compile-angel-excluded-files))
    (with-eval-after-load "cus-edit" (push (concat "/" (file-name-nondirectory custom-file))
                                           compile-angel-excluded-files))

    (compile-angel-on-load-mode))
#+END_SRC

** Fix GNU ELPA Keyring
The ELPA keyring sometimes gets screwed up, this fixes it
#+BEGIN_SRC emacs-lisp :lexical t
  (package! gnu-elpa-keyring-update :auto)
#+END_SRC

** Library requirements
#+BEGIN_SRC emacs-lisp :lexical t
  (package! dash :auto)
  (package! memo "thornjad/emacs-memo")
  (package! async :auto :commands (async-save))
  (package! popup :auto)
  (package! spinner :auto)
  (package! ripgrep :auto :defer 3)
#+END_SRC

JSONRPC is used by Eglot, Dape, Copilot and others. It is builtin, but we want to stop logging everything as a performance optimization.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! jsonrpc :builtin
    :config
    ;; Don't waste time logging events
    (fset #'jsonrpc--log-event #'ignore))
#+END_SRC

** PATH from shell
We only really need this in MacOS, grabbing environment variables from the default shell

#+BEGIN_SRC emacs-lisp :lexical t
  (package! exec-path-from-shell :auto
    :when (or (memq window-system '(mac ns x)) (daemonp))
    :config
    (dolist (var '("PATH" "SSH_AUTH_SOCK" "SSH_AGENT_PID" "GPG_AGENT_INFO"
                   "LANG" "LC_CTYPE" "NIX_SSL_CERT_FILE" "NIX_PATH" "PATH"
                   "MANPATH" "INFOPATH" "LSP_USE_PLISTS" "HOMEBREW_PREFIX"
                   "HOMEBREW_CELLAR" "HOMEBREW_REPOSITORY"))
      (add-to-list 'exec-path-from-shell-variables var))
    (exec-path-from-shell-initialize))
#+END_SRC

* Foundational functionality
** Keybindings
*** Which-key
Gives us a variety of menus for keybindings, and integrates nicely with General

#+BEGIN_SRC emacs-lisp :lexical t
  (package! which-key :builtin
    :defines which-key-mode
    :config
    (which-key-mode)
    (setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL")))
#+END_SRC

*** General
The vast majority of keybindings are set up with General. A lot of this could be done almost as easily with regular keybinding, but General gives us an easier time setting up a leader key and better which-key integration.

Most bindings will fall under the =SPC= leader key, so we generate a macro called =aero-leader-def= to make it easier for other packages to add their own bindings under this leader. For mode-specific keybindings, we use =SPC ,= as the leader, and a corresponding =aero-mode-leader-def= to suit.

From there, we set up all the main keybindings.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! general :auto
    :functions (general-define-key aero-leader-def aero-mode-leader-def)
    :init
    (setq-default general-override-states
                  '(insert hybrid normal visual motion operator replace))

    (general-create-definer aero-leader-def
      :states '(normal visual emacs motion)
      :prefix "SPC"
      :non-normal-prefix "C-SPC")

    (general-create-definer aero-mode-leader-def
      :states '(normal visual emacs motion)
      :prefix "SPC ,")

    :config
    (general-define-key
     :states '(normal visual motion)
     :keymaps 'override
     :prefix "SPC"
     :non-normal-prefix "C-SPC"
     "" nil)

    (general-def
      (kbd "C-h") 'delete-backward-char
      (kbd "C-w") 'aero/smarter-backward-kill-word
      (kbd "C-TAB") 'insert-tab
      (kbd "M-TAB") 'aero/alternate-buffer
      (kbd "C-RET") 'aero/browse-url-open)

    ;; Ensure keyboard quit does what we want
    (global-set-key [remap keyboard-quit] #'aero/keyboard-quit-context)

    (general-define-key
     :states 'normal
     :prefix "SPC"
     "fW" 'evil-write-all
     "w/" '(evil-window-vsplit :wk "split vertical")
     "w-" '(evil-window-split :wk "split horizontal")
     "cm" 'evil-make)

    (general-define-key
     :states '(normal insert motion)
     :keymaps 'override
     :prefix ","
     "" nil)

    (general-define-key
     :states '(normal insert motion)
     :keymaps 'override
     :prefix "SPC"
     :non-normal-prefix "C-SPC"
     "" nil

     ;; independent keys
     "SPC" 'execute-extended-command
     "TAB" '(aero/alternate-buffer :wk "alternate buffer")
     (kbd "ESC") 'keyboard-quit
     (kbd "C-g") 'keyboard-quit
     (kbd "<pause>") 'keyboard-quit
     "'" 'eshell
     "\"" '(aero/eshell-new :wk "eshell-new")
     ":" 'eval-expression
     ";" 'aero/comment-dwim
     "!" 'shell-command
     "=" 'quick-calc

     "," '(:ignore t :wk "mode") ; reserved for mode-specific

     "e" '(:ignore t :wk "errors")
     "ed" 'toggle-debug-on-error
     "eq" 'toggle-debug-on-quit

     "T TAB" 'tab-recent
     "T" '(:ignore t :wk "tab")
     "Tn" 'tab-next
     "Tp" 'tab-previous
     "Tk" 'tab-close
     "T," 'tab-rename
     "Tc" '(tab-new :wk "create tab")
     "Tb" 'switch-to-buffer-other-tab
     "Tf" 'find-file-other-tab
     "Ts" '(tab-duplicate :wk "tab duplicate split")
     "Tu" 'tab-undo

     "U" 'universal-argument

     "a" '(:ignore t :wk "applications")
     "ai" '(:ignore t :wk "AI functions")

     "b" '(:ignore t :wk "buffers")
     "bs" 'switch-to-scratch-buffer
     "bS" 'switch-to-new-scratch-buffer
     "bd" 'kill-current-buffer
     "bi" 'indent-buffer
     "bl" 'ibuffer
     "bm" 'switch-to-messages-buffer
     "bn" 'next-buffer
     "bp" 'previous-buffer
     "br" '(aero/reopen-file-at-buffer :wk "buffer replace")
     "bR" '(revert-buffer-quick :wk "buffer revert")
     "bw" '(whitespace-mode :wk "whitespace")
     "bx" 'kill-buffer-and-window

     "n" '(:ignore t :wk "narrow")
     "nn" 'narrow-to-region
     "np" 'narrow-to-page
     "nw" 'widen
     "nd" 'narrow-to-defun

     "c" '(:ignore t :wk "compile")
     "ct" 'aero/tail-compilation-buffer
     "ci" '(ielm :wk "ielm repl")
     "cc" 'compile
     "ce" '(:ignore t :wk "elisp")
     "ceb" 'eval-buffer
     "ced" 'eval-defun
     "cer" 'eval-region
     "ck" 'kill-compilation
     "cr" 'recompile

     "f" '(:ignore t :wk "files")
     "ff" 'find-file
     "fc" 'aero/copy-file-relative-to-project
     "fD" '(aero/delete-this-file :wk "delete this file")
     "fR" '(aero/rename-this-file-and-buffer :wk "rename this file")
     "fo" '(:ignore t :wk "open special files")
     "fot" '(:ignore t :wk "thornlog")
     "fott" '(aero/thornlog-todo :wk "thornlog todo")
     "fotl" '(aero/thornlog-log :wk "thornlog log")
     "fote" 'aero/open-emacs-config
     "fotd" '(aero/thornlog-dir :wk "thornlog all")
     "fw" '(save-buffer :wk "write buffer")
     "fh" '(aero/toggle-angular-component-file :wk "toggle angular component file")

     "g" '(:ignore t :wk "git")
     "gf" '(:ignore t :wk "files")

     "h" '(:ignore t :wk "help/manual")
     "hI" 'info-apropos
     "hM" 'woman
     "hd" '(:ignore t :wk "describe")
     "hdF" 'describe-face
     "hdb" 'describe-bindings
     "hdM" 'describe-mode
     "hdK" 'describe-keymap
     "hdC" 'describe-char
     "hdp" 'describe-package
     "hdi" '(emacs-index-search :wk "search emacs manual")
     "hdl" '(find-library :wk "describe library")
     "hi" 'info
     "hm" 'man
     "hw" '(:ignore t :wk "which-key")
     "hwm" '(which-key-show-major-mode :wk "major mode map")

     "j" '(:ignore t :wk "jump")
     "l" '(:ignore t :wk "lsp")

     "m" '(:ignore t :wk "mode")
     "m" '(tmm-menubar :wk "Context menu")

     "o" '(:ignore t :wk "org / outline")
     "oh" '(outline-hide-body :wk "hide all")
     "oS" '(outline-show-all :wk "show all")

     "p" '(:ignore t :wk "project")
     "pr" '(xref-find-definitions :wk "find ref")
     "ps" '(:ignore t :wk "spelling")

     "r" '(:ignore t :wk "xref")
     "rf" 'xref-find-definitions
     "rF" 'xref-find-definitions-other-window
     "rp" 'xref-go-back
     "rn" 'xref-go-forward
     "ra" 'xref-find-apropos
     "rr" 'xref-find-references

     "q" '(:ignore t :wk "quoted insert")
     "ql" 'insert-lambda
     "qq" 'quoted-insert
     "qp" 'aero/insert-pdb
     "qu" 'insert-char

     "s" '(:ignore t :wk "sexp")

     "t" '(:ignore t :wk "tabs/text")
     "td" 'dictionary-lookup-definition
     "tD" 'downcase-dwim
     "tU" 'upcase-dwim
     "tf" 'fill-paragraph
     "tF" 'aero/fill-to-80
     "tn" '(:ignore t :wk "number")
     "tnd" 'decrement-number-at-point
     "tni" 'increment-number-at-point
     "ts" 'sort-lines

     "u" 'undo-tree-visualize

     "w" '(:ignore t :wk "window/web")
     "w=" 'balance-windows
     "wB" '(aero/switch-to-minibuffer-window :wk "switch to minibuffer")
     "ws" '(eww-search-words :which-key "web search")
     "ww" 'eww
     "wb" '(:ignore t :wk "browse")
     "wbb" 'eww-list-buffers
     "wbh" 'eww-list-histories
     "wbm" 'eww-list-bookmarks
     "wbp" 'browse-url-at-point
     "wp" 'browse-url-at-point
     "wc" 'aero/toggle-compilation-buffer
     "wd" 'delete-window
     "wh" 'windmove-left
     "wi" 'minimize-window
     "wj" 'windmove-down
     "wk" 'windmove-up
     "wl" 'windmove-right
     "wm" 'maximize-window
     "wo" 'aero/browse-url-open
     "w{" 'shrink-window
     "w}" 'enlarge-window

     "z" 'repeat))
#+END_SRC

** Evil
#+begin_quote
"Emacs is a great operating system, lacking only a decent editor." — ancient Vi proverb
#+end_quote

I'm going to say it, Vi has a better navigation scheme than default Emacs. Even with a thumb-cluster keyboard, I don't want to hold Ctrl basically at all. Evil provides the best of Vi with the power of Emacs, but it needs some heavy configuration to work well.

The "wants" setup /must/ be in =:init= because Evil needs these set prior to setting up everything else.

Note that =evil-want-keybinding= is set to =nil= because =evil-collection= will handle that for us.

To change the =undo-system= without restarting Emacs, run =(evil-set-undo-system)=.

In visual mode, use =<= and =>= to indent/unindent the line(s)

#+BEGIN_SRC emacs-lisp :lexical t
  (package! evil :auto
    :init
    (setq evil-want-keybinding nil
          evil-undo-system 'undo-tree
          evil-want-fine-undo t
          evil-want-C-i-jump nil
          evil-want-C-u-scroll t
          evil-search-module 'isearch)

    :config
    ;; Free up some non-useful bindings for other uses.
    (define-key evil-motion-state-map " " nil)
    (define-key evil-motion-state-map (kbd "RET") nil)
    (define-key evil-motion-state-map (kbd "C-o") nil)

    ;; Set up default states. It's Normal for almost everything, but Evil doesn't handle Dired very
    ;; well, so we fall back on Emacs mode for that.
    (setq evil-default-state 'normal)
    (evil-set-initial-state 'dired-mode 'emacs)
    (evil-set-initial-state 'message-mode 'motion)

    ;; Make movement keys work visually, just like other kinds of movement, by remapping.
    (define-key evil-normal-state-map (kbd "<remap> <evil-next-line>")
      'evil-next-visual-line)
    (define-key evil-normal-state-map (kbd "<remap> <evil-previous-line>")
      'evil-previous-visual-line)
    (define-key evil-motion-state-map (kbd "<remap> <evil-next-line>")
      'evil-next-visual-line)
    (define-key evil-motion-state-map (kbd "<remap> <evil-previous-line>")
      'evil-previous-visual-line)

    (setq-default evil-cross-lines nil)
    (define-key evil-visual-state-map (kbd "u") 'undo)

    ;; By default, these two operate on half pages, but I prefer the smaller jump
    (defun aero/scroll-quarter-page-down ()
      (interactive)
      (evil-scroll-down (/ (window-body-height) 4)))
    (defun aero/scroll-quarter-page ()
      (interactive)
      (evil-scroll-up (/ (window-body-height) 4)))
    (evil-define-key nil global-map (kbd "C-u") #'aero/scroll-quarter-page-up)
    (evil-define-key nil global-map (kbd "C-d") #'aero/scroll-quarter-page-down)

    ;; Define =vig= and =vag= to look for all paren types
    (defun aero/evil-paren-range (count beg end type inclusive)
      "Get minimum range of paren text object.
      COUNT, BEG, END, TYPE is used.  If INCLUSIVE is t, the text object is inclusive."
      (let* ((parens '("()" "[]" "{}" "<>"))
             range
             found-range)
        (dolist (p parens)
          (condition-case nil
              (setq range (evil-select-paren (aref p 0) (aref p 1) beg end type count inclusive))
            (error nil))
          (when range
            (cond
             (found-range
              (when (< (- (nth 1 range) (nth 0 range))
                       (- (nth 1 found-range) (nth 0 found-range)))
                (setf (nth 0 found-range) (nth 0 range))
                (setf (nth 1 found-range) (nth 1 range))))
             (t
              (setq found-range range)))))
        found-range))
    (evil-define-text-object aero/evil-a-paren (count &optional beg end type)
      "Select a paren."
      :extend-selection t
      (aero/evil-paren-range count beg end type t))
    (evil-define-text-object aero/evil-inner-paren (count &optional beg end type)
      "Select 'inner' paren."
      :extend-selection nil
      (aero/evil-paren-range count beg end type nil))
    (define-key evil-inner-text-objects-map "g" #'aero/evil-inner-paren)
    (define-key evil-outer-text-objects-map "g" #'aero/evil-a-paren)

    (defun aero/evil-shift-right ()
      (interactive)
      (evil-shift-right evil-visual-beginning evil-visual-end)
      (evil-normal-state)
      (evil-visual-restore))
    (defun aero/evil-shift-left ()
      (interactive)
      (evil-shift-left evil-visual-beginning evil-visual-end)
      (evil-normal-state)
      (evil-visual-restore))
    (evil-define-key 'visual global-map (kbd ">") 'aero/evil-shift-right)
    (evil-define-key 'visual global-map (kbd "<") 'aero/evil-shift-left)

    ;; Make =:q= kill the buffer instead of Emacs itself
    (evil-ex-define-cmd "q" 'kill-current-buffer)

    ;; AFAIK there's no "backward" equivalent to "e", so we set it to backward word
    (evil-define-key '(normal visual motion) global-map
      (kbd "C-e") #'evil-backward-word-end)
    (evil-define-key '(normal visual motion) global-map
      (kbd "C-M-e") #'evil-backward-WORD-end)

    ;; Useful for pasting into the minibuffer, since Evil doesn't properly function there
    (evil-define-key '(insert) global-map (kbd "C-y") #'evil-paste-after)
    (evil-define-key '(insert) global-map (kbd "C-S-y") #'evil-paste-before)

    (evil-mode +1))
#+END_SRC

*** Evil collection
Provides Evil defaults for many modes which Evil proper overlooks

#+BEGIN_SRC emacs-lisp :lexical t
  (package! evil-collection :auto
    :after evil
    :config (evil-collection-init))
#+END_SRC

*** Evil-matchit
Allows % to jump matching tags

#+BEGIN_SRC emacs-lisp :lexical t
  (package! evil-matchit :auto
    :defer 5
    :after evil
    :defines global-evil-matchit-mode
    :config (global-evil-matchit-mode 1))
#+END_SRC

** Treesitter
*** Treesit-auto
Automatically installs treesitter grammars when they're missing, because for some reason Emacs doesn't do this already.

The call to =treesit-auto-add-to-auto-mode-alist= adds all treesitter modes to auto-mode-alist as long as they're =treesit-ready-p=. I previously had this set to ='all= but this started installing some grammars which are in-progress and thus error when you try to use them.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! treesit-auto :auto
    :when (treesitterp)
    :custom
    (treesit-auto-install 'prompt)

    :config
    (treesit-auto-add-to-auto-mode-alist)

    ;; Python does not play nice with treesitter, as of 2024, so we pin to a working version.
    (defvar aero/python-treesit-auto-recipe
      (make-treesit-auto-recipe
       :lang 'python
       :ts-mode 'python-ts-mode
       :remap 'python-mode
       :url "https://github.com/tree-sitter/tree-sitter-python"
       :ext "\\.py[iw]?\\'"
       :revision "v0.21.0")
      "Recipe for libtree-sitter-python.dylib")
    (add-to-list 'treesit-auto-recipe-list aero/python-treesit-auto-recipe)

    (global-treesit-auto-mode +1))
#+END_SRC

** Completion and navigation
*** Vertico
Provides a completion system similar to Ivy, but it's faster and more lightweight. Also make sure selections can wrap around the top and bottom of the menu.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! vertico :auto
    :init (vertico-mode)
    :custom
    (vertico-cycle t)

    :config
    (defun aero/vertico-directory-up-maybe ()
      "Go up a directory if completing a file name, otherwise delete char."
      (interactive)
      (if (and (eq (char-before) ?/)
               (minibufferp)
               minibuffer-completing-file-name)
          (vertico-directory-up)
        (delete-char -1)))
    (define-key vertico-map (kbd "DEL") #'aero/vertico-directory-up-maybe))
#+END_SRC

*** Marginalia
This provides a more informative completion system, showing more information about the candidates.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! marginalia :auto :init (marginalia-mode))
#+END_SRC

*** Orderless
This provides a more flexible completion system where we can use spaces to separate search terms, inputting them in any order.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! orderless :auto
    :custom
    (completion-styles '(substring orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion))))
    (read-file-name-completion-ignore-case t)
    (read-buffer-completion-ignore-case t)
    (completion-ignore-case t))
#+END_SRC

*** Consult
Super useful package, providing a variety of wrappers that provide a powerful and consistent completing-read interface. I also hook it into Xref for more seamless integration.

Buffer previews are debounced, since I often don't want them.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun consult-outline-top ()
    (interactive)
    (funcall #'consult-outline 1))

  (package! consult :auto
    :after (general evil orderless)
    :commands (consult-line
               consult-buffer
               consult-outline
               consult-imenu
               consult-flymake
               consult-theme
               consult-ripgrep)
    :custom
    (xref-show-xrefs-function #'consult-xref)
    (xref-show-definitions-function #'consult-xref)
    (consult-preview-key '(:debounce 0.4 any))

    :init
    (aero-leader-def
      "/" 'consult-line
      "bb" 'consult-buffer
      "jo" 'consult-outline
      "jO" 'consult-outline-top
      "ji" 'consult-imenu
      "je" 'consult-flymake
      "ja" 'consult-org-agenda
      "jh" 'consult-org-heading
      "p/" 'consult-ripgrep
      "Et" 'consult-theme
      "j'" 'consult-mark)

    :config
    (add-hook 'eshell-mode-hook (lambda () (setq outline-regexp eshell-prompt-regexp)))

    (defun consult--orderless-regexp-compiler (input type &rest _config)
      (setq input (cdr (orderless-compile input)))
      (cons
       (mapcar (lambda (r) (consult--convert-regexp r type)) input)
       (lambda (str) (orderless--highlight input t str))))
    (defun consult--with-orderless (&rest args)
      "Use Orderless to compile the regexp for consult-ripgrep."
      (minibuffer-with-setup-hook
          (lambda ()
            (setq-local consult--regexp-compiler #'consult--orderless-regexp-compiler))
        (apply args)))
    (advice-add #'consult-ripgrep :around #'consult--with-orderless)

    ;; Allow =n= and =N= to continue the search after =consult-line= exits. Note that this only
    ;; supports the first search term when using orderless syntax.
    (defun aero/consult-line-isearch-history (&rest _)
      "Add latest `consult-line' search pattern to the isearch history."
      (when (and (bound-and-true-p evil-mode)
                 (eq evil-search-module 'isearch)
                 consult--line-history)
        (let* ((pattern (car consult--line-history))
               (pattern (car (split-string pattern)))
               (regexp (if (string-prefix-p "\\_" pattern)
                           (substring pattern 2)
                         pattern)))
          (add-to-history 'regexp-search-ring regexp)
          (setq evil-ex-search-direction 'forward))))
    (advice-add #'consult-line :after #'aero/consult-line-isearch-history)

    (defun crm-indicator (args)
      "Add prompt indicator to `completing-read-multiple'.
    We display [CRM<separator>], e.g., [CRM,] if the separator is a comma."
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator))

#+END_SRC

*** Amx
Enhances =execute-extended-command= by showing recently used commands and keyboard shortcuts.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! amx "DarwinAwardWinner/amx"
    :defer 1
    :init (amx-mode 1))
#+END_SRC

*** Yasnippet
Yasnippet provides a powerful templating system for inserting boilerplate code.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! yasnippet "joaotavora/yasnippet"
    :custom
    (yas-installed-snippets-dir aero-snippets-dir)
    :config
    (yas-global-mode 1))
#+END_SRC

**** Consult-yasnippet
Plug yasnipet into consult for a better interface to snippets

#+BEGIN_SRC emacs-lisp :lexical t
  (package! consult-yasnippet "mohkale/consult-yasnippet"
    :after (consult yasnippet)
    :config
    (aero-leader-def
      "y" 'consult-yasnippet))
#+END_SRC

*** Recentf (builtin)
Recentf provides a list of recently opened files, and is honestly one of the main ways I open buffers.

Doesn't seem like indent activates properly for me without an intervention into the save list. Here we move it to a known cache file and set up an auto-save every 5 minutes.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! recentf :builtin
    :defer 1
    :defines (recentf-mode)

    :preface
    (defun aero/recentf-save-list-quiet ()
      "Wrapper for `recentf-save-list' with no message."
      (let ((inhibit-message t))
        (recentf-save-list)))

    :custom
    (recentf-save-file (expand-file-name ".recentf" user-emacs-directory))
    (recentf-max-saved-items 500)

    :config
    (recentf-mode 1)
    (run-at-time 60 (* 5 60) #'aero/recentf-save-list-quiet))
#+END_SRC

*** All-the-icons
Support for icon insertion, and used as a lib in other packages

#+BEGIN_SRC emacs-lisp :lexical t
  (package! all-the-icons (:repo "domtronn/all-the-icons.el" :files (:defaults "data"))
    :after (general)
    :defer 1
    :when (display-graphic-p)
    :config (aero-leader-def "qi" 'all-the-icons-insert))
#+END_SRC

*** Avy
Utility for visual navgation

#+BEGIN_SRC emacs-lisp :lexical t
  (package! avy "abo-abo/avy"
    :after (general)
    :init
    (general-define-key
     :states '(normal visual)
     :prefix "SPC"
     "jl" '(avy-goto-line :wk "jump to line")
     "jc" '(avy-goto-char :wk "jump to char")
     "jj" '(avy-goto-char :wk "jump to char")
     "jw" '(avy-goto-word-1 :wk "jump to word")))
#+END_SRC

**** Ace-link
Jump to links in eww with Avy

#+BEGIN_SRC emacs-lisp :lexical t
  (package! ace-link "abo-abo/ace-link"
    :after (avy eww)
    :functions (ace-link-setup-default)
    :config (ace-link-setup-default))
#+END_SRC

*** Smartscan
Gives us the =M-n= and =M-p= symbol-following ability

#+BEGIN_SRC emacs-lisp :lexical t
  (package! smartscan "mickeynp/smart-scan"
    :hook ((prog-mode org-mode) . smartscan-mode)
    :config
    (advice-add 'smartscan-symbol-go-forward :around #'aero/advice-disable-subword)
    (advice-add 'smartscan-symbol-go-backward :around #'aero/advice-disable-subword))
#+END_SRC

Advice to disabled subword-mode used during scanning

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/advice-disable-subword (orig-fun &rest args)
    "Disable `subword-mode' around the given function."
    (let ((original-mode subword-mode))
      (subword-mode -1)
      (apply orig-fun args)
      (subword-mode original-mode)))
#+END_SRC

*** Undo-tree
Provides a visual representation of the undo history.

By default, auto-saves to the local directory, but that's annoying, so we move it to the cache directory. Also enable timestamps and diffs in the visualizer.

=undo-in-region= is disabled entirely because it's buggy enough that it will drop your undo history in some situations without warning.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! undo-tree "apchamberlain/undo-tree.el"
    :custom
    (undo-tree-auto-save-history nil)
    (undo-tree-history-directory-alist
     `((".*" . ,(expand-file-name "undo-tree/" aero-cache-dir))))
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t)
    (undo-tree-enable-undo-in-region nil)

    :config
    (global-undo-tree-mode +1)
    (add-hook 'evil-local-mode-hook 'turn-on-undo-tree-mode))
#+END_SRC

*** Winner
Provides a way to undo/redo window configurations.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! winner :builtin
    :after (general)
    :defines winner-boring-buffers
    :config
    ;; list of buffers that winner-undo won't restore
    (setq winner-boring-buffers
          '("*Completions*"
            "*Compile-Log*"
            "*inferior-lisp*"
            "*Fuzzy Completions*"
            "*Apropos*"
            "*Help*"
            "*cvs*"
            "*Buffer List*"
            "*Ibuffer*"
            "*esh command on file*"))
    (winner-mode 1)
    (aero-leader-def
      "wu" 'winner-undo
      "wU" 'winner-redo))
#+END_SRC

** Winum
Jump to windows by number. 1 is the upper-left-most

#+BEGIN_SRC emacs-lisp :lexical t
  (package! winum "deb0ch/emacs-winum"
    :defer 5
    :after (general which-key)
    :init
    (winum-mode)
    :config
    (aero-leader-def
      "1" '(winum-select-window-1 :wk "window-1")
      "2" '(winum-select-window-2 :wk "window-2")
      "3" '(winum-select-window-3 :wk "window-3")
      "4" '(winum-select-window-4 :wk "window-4")
      "5" '(winum-select-window-5 :wk "window-5")
      "6" '(winum-select-window-6 :wk "window-6")
      "7" '(winum-select-window-7 :wk "window-7")
      "8" '(winum-select-window-8 :wk "window-8")
      "9" '(winum-select-window-9 :wk "window-9")))
#+END_SRC

** Company completions
I can't believe this isn't built-in. Company provides a completion system that's more powerful than the default.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! company
    (:repo "company-mode/company-mode"
     :files (:defaults "icons" ("images/small" "doc/images/small/*.png")))
    :after (evil)
    :hook ((prog-mode . company-mode)
           (company-mode-hook . evil-normalize-keymaps))
    :init
    (setq company-idle-delay 0.2
          company-selection-wrap-around t
          company-minimum-prefix-length 2
          company-dabbrev-downcase nil
          company-tooltip-limit 15
          company-tooltip-margin 2
          company-require-match nil
          company-show-numbers t
          company-tooltip-align-annotations t
          company-dabbrev-other-buffers t ; only look in open buffers with same major mode
          company-global-modes '(not
                                 erc-mode message-mode help-mode gud-mode vterm-mode))
    :config
    ;; Wait until it's defined, then disable preview after point
    (setq company-frontends (delq 'company-preview-if-just-one-frontend company-frontends)))
#+END_SRC

*** Company-prescient
Moves commonly-used completions to the top, and provides a better sorting algorithm.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! company-prescient
    (:host github
     :repo "radian-software/prescient.el"
     :files ("company-prescient.el"))
    :after (company)
    :hook (company-mode . company-prescient-mode)
    :custom (prescient-save-file (expand-file-name "prescient-save.el" aero-cache-dir))
    :config (prescient-persist-mode +1))
#+END_SRC

*** Company-box
Provides a better popup interface for company

#+BEGIN_SRC emacs-lisp :lexical t
  (package! company-box
    (:repo "sebastiencs/company-box" :files (:defaults "images"))
    :hook (company-mode . company-box-mode))
#+END_SRC

** Tramp
Tramp provides a way to edit files on remote servers. This was a way of life in a previous job, but I haven't touched it in several years. I'm keeping it around just in case, frozen in time. The =:defer t= ensures it's not loaded until it's needed.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! tramp :builtin
    :defer t
    :functions tramp-cleanup-all-connection
    :custom
    (tramp-auto-save-directory
     (expand-file-name "tramp/autosave" aero-cache-dir))
    (tramp-persistency-file-name
     (expand-file-name "tramp/persistency" aero-cache-dir))
    (tramp-use-ssh-controlmaster-options nil)  ; use system settings instead
    (tramp-default-method "rsync")
    (tramp-terminal-type "tramp"))
#+END_SRC

** Dired
This is a file manager in Emacs, but I really struggle to use it

#+BEGIN_SRC emacs-lisp :lexical t
  (package! dired :builtin
    :hook ((dired-mode . hl-line-mode)
           (dired-mode . dired-async-mode))
    :bind (:map dired-mode-map
           ("M-n" . #'dired-next-dirline)
           ("M-p" . #'dired-prev-dirline)
           ("TAB" . #'dired-next-subdir)))
#+END_SRC

** Language server
*** Eglot
The introduction of the language server has been a game-changer. It provides a consistent interface for code completion, linting, and refactoring across quite a few languages. I've tried LSP-mode, but it's too slow and heavy for my taste. Eglot is built-in and lightweight.

Using =:hook= we ensure it's enabled for particular languages, rather than trying to enable in every buffer.

Set =eglot-confirm-server-initiated-edits= to nil to stop an infuriating default behavior that confirms editing a file immediately after explicitly initiating editing the file.

Event logging is disabled to provide a slight performance boost, with no real downside.

Document highlighting is disabled because most language servers are pretty slow at it. We use =highlight-thing= instead.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eglot :builtin
    :hook ((python-mode
            python-ts-mode
            clojure-mode
            typescript-mode
            typescript-ts-mode
            astro-mode
            js-mode
            js-ts-mode)
           . eglot-ensure)
    :after (general project)

    :custom
    (eglot-confirm-server-initiated-edits nil)
    (eglot-autoshutdown t)
    (eglot-events-buffer-size 0)
    (eglot-send-changes-idle-time 0.75)
    (eglot-ignored-server-capabilities '(:documentHighlightProvider))

    :config
    (setq-default eglot-workspace-configuration
                  '(:pylsp (:plugins (:pycodestyle (:enabled :json-false)
    				                          :pyls_mypy (:enabled t :live_mode :json-false)
    				                          :pyls_black (:enabled t)
    				                          :pyls_isort (:enabled t)))))
    ;; Create binding for Astro
    (add-to-list 'eglot-server-programs
                 '(astro-mode . ("astro-ls" "--stdio"
                                 :initializationOptions
                                 (:typescript (:tsdk "./node_modules/typescript/lib")))))

    (aero-leader-def
      "la" 'eglot-code-actions
      "lf" '(:ignore t :wk "find")
      "lfr" 'xref-find-references
      "lfd" 'eglot-find-declaration
      "lfi" 'eglot-find-implementation
      "lft" 'eglot-find-typeDefinition
      "lr" '(:ignore t :wk "refactor")
      "lrr" 'eglot-rename
      "lrf" 'eglot-format
      "lro" 'eglot-code-action-organize-imports))
#+END_SRC

**** Eglot-booster
Optimizations to Eglot, using emacs-lsp-booster under the hood. emacs-lsp-booster must have been installed already (its a Rust binary), which can be done with =make install-deps= or the more specific =make lsp-booster=

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eglot-booster "jdtsmith/eglot-booster"
    :after eglot
    :config (eglot-booster-mode))
#+END_SRC

**** Eglot-signature-eldoc-talkative
Make eglot send more info to eldoc, including parameter and function documentation

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eglot-signature-eldoc-talkative
    (:host codeberg :repo "mekeor/eglot-signature-eldoc-talkative" :branch "default")
    :after (eglot)
    :config (advice-add #'eglot-signature-eldoc-function :override #'eglot-signature-eldoc-talkative))
#+END_SRC

*** Eldoc-box
Puts eldoc in a child frame instead of the echo area. It's set up so that it only shows up when you want it to, rather than clobbering the minibuffer or showing on top of other code.

Includes a function to ensure we fix the documentation strategy to show all of the available eldoc information when we want it. This way Flymake errors don't just get clobbered by docstrings.

The configuration leaves single-line docs in the minibuffer, and shows multi-line docs in the child frame only when requested. Since we always show when the user requests it, max height and width are not important.


#+BEGIN_SRC emacs-lisp :lexical t
  (package! eldoc-box "casouri/eldoc-box"
    :after general

    :preface
    (defun aero/eldoc-set-documentation-strategy ()
      (setq-local eldoc-documentation-strategy #'eldoc-documentation-compose))

    (defun aero/eldoc-box-help-at-point ()
      "Display full eldoc at point on command"
      (interactive)
      (let ((eldoc-echo-area-use-multiline-p t))
        (call-interactively #'eldoc-box-help-at-point)))

    :hook (eglot-managed-mode . aero/eldoc-set-documentation-strategy)

    :custom
    (eldoc-idle-delay 0.5)
    (eldoc-box-only-multi-line nil)
    (eldoc-echo-area-use-multiline-p nil)
    (eldoc-box-max-pixel-height 99999)
    (eldoc-box-max-pixel-width 99999)

    :init
    (aero-leader-def "i" 'aero/eldoc-box-help-at-point)

    :config
    (add-hook 'eldoc-box-buffer-setup-hook #'eldoc-box-prettify-ts-errors 0 t))
#+END_SRC

** System-specific setup
Mac needs some extra hand-holding to connect the kill-ring to the system clipboard. Linux just needs the functionality enabled.

#+BEGIN_SRC emacs-lisp :lexical t
  (when (system-is-mac)
    (defvar aero/pbcopier-program (executable-find "pbcopy")
      "Name of Pbcopy program tool.")
    (defvar aero/pbcopier-last-selected-text-clipboard nil
      "The value of the CLIPBOARD X selection from pbcopy.")
    (defvar aero/pbcopier-last-selected-text-primary nil
      "The value of the PRIMARY X selection from pbcopy.")

    (defun aero/pbcopier-set-selection (type data)
      "TYPE is a symbol: primary, secondary and clipboard.
  See `x-set-selection'."
      (when aero/pbcopier-program
        (let* ((process-connection-type nil)
               (proc (start-process "pbcopy" nil "pbcopy"
                                    "-selection" (symbol-name type))))
          (process-send-string proc data)
          (process-send-eof proc))))

    (defun aero/pbcopier-select-text (text)
      "See `x-select-text'."
      (aero/pbcopier-set-selection 'primary text)
      (setq aero/pbcopier-last-selected-text-primary text)
      (aero/pbcopier-set-selection 'clipboard text)
      (setq aero/pbcopier-last-selected-text-clipboard text))

    (defun aero/pbcopier-selection-value ()
      "See `x-cut-buffer-or-selection-value'."
      (when aero/pbcopier-program
        (let (clip-text primary-text)
          (let ((tramp-mode nil)
                (default-directory "~"))
            (setq clip-text (shell-command-to-string "pbpaste")))
          (setq clip-text
                (cond ;; check clipboard selection
                 ((or (not clip-text) (string= clip-text ""))
                  (setq aero/pbcopier-last-selected-text-primary nil))
                 ((eq      clip-text aero/pbcopier-last-selected-text-clipboard) nil)
                 ((string= clip-text aero/pbcopier-last-selected-text-clipboard)
                  ;; Record the newer string,
                  ;; so subsequent calls can use the `eq' test.
                  (setq aero/pbcopier-last-selected-text-clipboard clip-text)
                  nil)
                 (t (setq aero/pbcopier-last-selected-text-clipboard clip-text))))
          (let ((tramp-mode nil)
                (default-directory "~"))
            (setq primary-text (shell-command-to-string "pbpaste")))
          (setq primary-text
                (cond ;; check primary selection
                 ((or (not primary-text) (string= primary-text ""))
                  (setq aero/pbcopier-last-selected-text-primary nil))
                 ((eq      primary-text aero/pbcopier-last-selected-text-primary) nil)
                 ((string= primary-text aero/pbcopier-last-selected-text-primary)
                  ;; Record the newer string,
                  ;; so subsequent calls can use the `eq' test.
                  (setq aero/pbcopier-last-selected-text-primary primary-text)
                  nil)
                 (t (setq aero/pbcopier-last-selected-text-primary primary-text))))
          (or clip-text primary-text))))

    (declare-function aero/pbcopier-select-text "aero-pbcopier.el")
    (declare-function aero/pbcopier-selection-value "aero-pbcopier.el")
    (setq interprogram-cut-function #'aero/pbcopier-select-text)
    (setq interprogram-paste-function #'aero/pbcopier-selection-value)

    (setq-default ns-use-native-fullscreen nil)
    (if (executable-find "gls")
        (progn
          (setq insert-directory-program "gls")
          (setq dired-listing-switches "-lFaGh1v --group-directories-first"))
      (setq dired-listing-switches "-ahlF")))
#+END_SRC

Linux only needs some functionality enabled.

#+BEGIN_SRC emacs-lisp :lexical t

  (when (system-is-linux)
    (setq select-enable-clipboard t
          interprogram-paste-function #'gui-selection-value
          x-gtk-use-system-tooltips t
          dired-listing-switches "-lFaGh1v --group-directories-first"))
#+END_SRC

** Editor setup
*** Editorconfig 
Provides a global minor mode that respects =.editorconfig= files.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! editorconfig :builtin
    :config (editorconfig-mode))
#+END_SRC

*** Unmodified-buffer
Detects when the buffer matches what's on disk and marks it unmodified. If, for example, you visit a file, change something, then undo the change, this package ensures the buffer doesn't think its still modified.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! unmodified-buffer "arthurcgusmao/unmodified-buffer"
    :defer 1
    :hook ((prog-mode text-mode) . unmodified-buffer-mode))
#+END_SRC

*** So-long mode
Performance enhancement for files with extremely long lines or exceptionally many lines. Use =so-long-revert= in a buffer to get back to what it would have otherwise loaded as.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! so-long :builtin
    :config (global-so-long-mode +1))
#+END_SRC

*** Savehist
Saves the minibuffer history.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! savehist :builtin
    :init (savehist-mode)
    :custom (savehist-file (expand-file-name "history" aero-cache-dir)))
#+END_SRC

*** Helpful
A better version of the built-in help buffers. This ought to be included in Emacs.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! helpful "Wilfred/helpful"
    :commands (helpful-function
               helpful-variable
               helpful-macro
               helpful-key
               helpful-callable)
    :after (evil general)
    :init
    (general-define-key
     :states 'normal
     :prefix "SPC"
     "hdf" 'helpful-function
     "hda" 'helpful-symbol
     "hdv" 'helpful-variable
     "hdm" 'helpful-macro
     "hdk" 'helpful-key
     "hdc" 'helpful-callable)

    :config
    (evil-define-key 'normal helpful-mode-map
      "q" 'kill-current-buffer
      "?" 'describe-mode))
#+END_SRC

* UI
** Aero modeline
My custom modeline. Exceptionally loosely based on Doom's modeline, but the code diverged many years ago.

#+BEGIN_SRC emacs-lisp :lexical t
  (defgroup aero/modeline nil
    "A minimal mode-line with useful information."
    :group 'mode-line)

  (defvar aero/modeline--bar-active nil)
  (defvar aero/modeline-bar--inactive nil)

  (defvar aero/modeline-height 30)
  (defvar aero/modeline-bar-width 5)

  (defvar aero/modeline--default-mode-line mode-line-format
    "Store the default mode-line format so it's not lost.")

  (defvar-local aero/modeline-hide--old-format nil
    "Storage for the old `mode-line-format', so it can be restored when
  `aero/modeline-hide-mode' is disabled.")

  ;; Ensure major-mode or theme changes can't overwrite this
  (put 'aero/modeline-hide--old-format 'permanent-local t)

  (defface aero/modeline-status-grayed-out '((t (:inherit (font-lock-doc-face) :slant italic)))
    "Face used for neutral or inactive status indicators in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-status-info '((t (:inherit (font-lock-keyword-face) :slant italic)))
    "Face used for generic status indicators in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-status-success '((t (:inherit (success) :slant italic)))
    "Face used for success status indicators in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-status-warning '((t (:inherit (warning) :slant italic)))
    "Face for warning status indicators in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-status-error '((t (:inherit (error) :slant italic)))
    "Face for error stauts indicators in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-unimportant '((t (:inherit (font-lock-doc-face))))
    "Face used for less important mode-line elements."
    :group 'aero/modeline)

  (defface aero/modeline-modified '((t (:inherit (error))))
    "Face used for the 'modified' indicator symbol in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-not-modified '((t (:inherit (success))))
    "Face used for the 'not modified' indicator symbol in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-read-only '((t (:inherit (warning))))
    "Face used for the 'buffer read-only' indicator symbol in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-remote '((t (:inherit (font-lock-keyword-face :weight bold))))
    "Face used for the 'not modified' indicator symbol in the mode-line."
    :group 'aero/modeline)

  (defface aero/modeline-evil-normal '((t (:inherit (font-lock-keyword-face))))
    "Face used for Normal Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-insert '((t (:inherit (font-lock-keyword-face))))
    "Face used for Insert Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-visual '((t (:inherit (font-lock-keyword-face))))
    "Face used for Visual Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-operator '((t (:inherit (font-lock-keyword-face))))
    "Face used for Visual Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-motion '((t (:inherit (font-lock-keyword-face))))
    "Face used for Visual Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-replace '((t (:inherit (font-lock-keyword-face))))
    "Face used for Replace Evil state message."
    :group 'aero/modeline)
  (defface aero/modeline-evil-emacs '((t (:inherit (font-lock-keyword-face))))
    "Face used for Emacs Evil state message."
    :group 'aero/modeline)

  (defface aero/modeline-major-mode-active '((t (:inherit mode-line-buffer-id)))
    "Face used for major mode."
    :group 'aero/modeline)

  (defface aero/modeline-git-branch '((t (:slant italic :bold t)))
    "Used for Git branch name."
    :group 'aero/modeline)

  (defface aero/modeline-bar '((t (:background unspecified)))
    "Style of the bar on the modeline."
    :group 'aero/modeline)
  (defface aero/modeline-bar-inactive '((t (:background unspecified)))
    "Style of the bar on the inactive modeline."
    :group 'aero/modeline)

  ;; TODO could this be memoized?
  (defun aero-info-line-format (left right)
    "Return a string of `window-width' length containing LEFT and RIGHT, aligned
  respectively."
    (let ((reserve (length right)))
      (concat left " " (propertize
                        " " 'display
                        `((space :align-to
                            (- (+ right right-fringe right-margin)
                               ,(+ reserve (if (display-graphic-p) 1 2))))))
              right)))

  (defvar aero/modeline--active-window nil)
  (defun aero/modeline--get-active-window (&optional frame)
    "Get the current window, but exclude child windows."
    (if (and (fboundp 'frame-parent) (frame-parent frame))
        (frame-selected-window (frame-parent frame))
      (frame-selected-window frame)))
  (defun aero/modeline--set-selected-window (&rest _)
    "Set `aero/modeline--active-window' to the correct window."
    (let ((win (aero/modeline--get-active-window)))
      (setq aero/modeline--active-window
            (if (minibuffer-window-active-p win)
                (minibuffer-selected-window)
              win))))
  (add-hook 'pre-redisplay-functions #'aero/modeline--set-selected-window)
  (defun aero/modeline--active-p ()
    "Return whether mode-line is active."
    (and aero/modeline--active-window
         (eq (aero/modeline--get-active-window) aero/modeline--active-window)))

  ;;; Segments

  (defun aero/modeline-segment-evil-state ()
    "Display current evil state. Requires function `evil-mode'."
    (when (require 'evil nil 'noerror)
      (declare-function evil-state-property "evil")
      (defvar evil-state)
      (let ((state (evil-state-property evil-state :tag t)))
        (cond
         ((functionp state) (propertize (funcall state) 'face 'aero/modeline-evil-visual))
         ((string= state " <N> ") (propertize state 'face 'aero/modeline-evil-normal))
         ((string= state " <I> ") (propertize state 'face 'aero/modeline-evil-insert))
         ((string= state " <R> ") (propertize state 'face 'aero/modeline-evil-replace))
         ((string= state " <O> ") (propertize state 'face 'aero/modeline-evil-operator))
         ((string= state " <M> ") (propertize state 'face 'aero/modeline-evil-motion))
         ((string= state " <E> ") (propertize state 'face 'aero/modeline-evil-emacs))
         (t state)))))

  (defun aero/modeline-segment-modified ()
    "Displays a color-coded buffer modification indicator in the mode-line."
    (cond
     ((and buffer-read-only (buffer-file-name))  ;; read-only
      (propertize "■" 'face `(:inherit aero/modeline-read-only :height 0.6)))
     ((string-match-p "\\*.*\\*" (buffer-name))  ;; special buffer
      (propertize "▼" 'face `(:inherit aero/modeline-read-only :height 0.6)))
     ((buffer-modified-p)  ;; modified
      (propertize "●" 'face `(:inherit aero/modeline-modified :height 0.65)))
     (t  ;; not modified
      (propertize "✔" 'face `(:inherit aero/modeline-not-modified :height 0.6)))))

  (defun aero/modeline-segment-git-state ()
    "Displays the current branch and status from Git.

  Only Git is supported because I'm not an animal."
    (when (and vc-mode buffer-file-name)
      (let ((state (vc-state (file-local-name buffer-file-name)))
            (str (if vc-display-status
                     (substring vc-mode 5)
                   "")))
        (concat
         (propertize
          (let ((max 12))
            (if (> (length str) max)
                (concat (substring str 0 (- max 3)) "…") ; substring 3 less than length limit
              str))
          'mouse-face 'mode-line-highlight
          'face 'aero/modeline-git-branch)
         " "))))

  (defun aero/modeline-segment-remote ()
    "Displays a symbol if buffer is remote"
    (when-let* ((filename (buffer-file-name))
                (host (file-remote-p filename 'host)))
      (concat " @" (propertize host 'face 'aero/modeline-remote) " ")))

  (defun aero/modeline-segment-buffer-name ()
    "Displays the name and size of the current buffer in the mode-line."
    (concat (propertize "%b" 'face 'mode-line-buffer-id) " "))

  (defun aero/modeline-segment-size-and-position ()
    "Displays the current cursor position in the mode-line."
    (concat "(%I) %l:%C %o%%"
            (when (use-region-p)
              (concat
               "  (" (number-to-string (count-lines (point) (mark)))
               ":" (number-to-string (abs (- (point) (mark))))
               ")"))
            "  "))

  (defun aero/modeline-segment-process ()
    "Displays the current value of `mode-line-process' in the mode-line."
    (when mode-line-process
      (list mode-line-process "  ")))

  (declare-function flymake--mode-line-counter "flymake")
  (defun aero/modeline-segment-flymake ()
    "Displays information about current flymake status."
    (when (bound-and-true-p flymake-mode)
      (list (flymake--mode-line-counter :error) " ")))

  (defun aero/modeline-segment-lsp ()
    "Displays information about LSP status."
    (cond
     ((bound-and-true-p lsp-mode)
      (list (propertize ""
                        'help-echo
                        (string-join
                         (mapcar (lambda (w)
                                   (format "[%s]\n" (lsp--workspace-print w)))
                                 (lsp-workspaces))))
            "  "))

     ((and (fboundp 'eglot-managed-p) (eglot-managed-p))
      (list "" "  "))))

  (defun aero/modeline-segment-major-mode ()
    "Displays the current major mode in the mode-line."
    (format " %s " (format-mode-line mode-name)))

  (defun aero/modeline-create-bar-image (face width height)
    "Create the bar image.
  Use FACE1 for the bar, FACE2 for the background.
  WIDTH and HEIGHT are the image size in pixels."
    (when (and (display-graphic-p)
               (image-type-available-p 'pbm))
      (propertize
       " " 'display
       (let ((color (or (face-background face nil t) "None")))
         (ignore-errors
           (create-image
            (concat (format "P1\n%i %i\n" width height)
                    (make-string (* width height) ?1)
                    "\n")
            'pbm t :foreground color :ascent 'center))))))

  (defun aero/modeline-segment-bar ()
    "The bar, also determines modeline height (in GUI)."
    (let ((width aero/modeline-bar-width)
          (height aero/modeline-height))
      (if (aero/modeline--active-p)
          (aero/modeline-create-bar-image 'aero/modeline-bar width height)
        (aero/modeline-create-bar-image 'aero/modeline-bar-inactive width height))))

  
  ;; Activation function

  ;;;###autoload
  (define-minor-mode aero/modeline-mode
    "Toggle aero/modeline on or off."
    :group 'aero/modeline
    :global t
    :lighter nil
    (progn
      ;; Set the new mode-line-format
      (setq-default mode-line-format
                    '((:eval
                       (aero-info-line-format
                        ;; Left
                        (format-mode-line
                         '((:eval (aero/modeline-segment-bar))
                           (:eval (aero/modeline-segment-evil-state))
                           " " (:eval (aero/modeline-segment-modified)) " "
                           (:eval (aero/modeline-segment-buffer-name))
                           (:eval (aero/modeline-segment-size-and-position))))

                        ;; Right
                        (format-mode-line
                         '((:eval (aero/modeline-segment-process))
                           (:eval (aero/modeline-segment-lsp))
                           (:eval (aero/modeline-segment-flymake))
                           (:eval (aero/modeline-segment-git-state))
                           (:eval (aero/modeline-segment-remote))
                           (:eval (aero/modeline-segment-major-mode))))))))))

  (define-globalized-minor-mode aero/modeline-global-mode aero/modeline-mode
    (lambda () (aero/modeline-mode 1)))

  (define-minor-mode aero/modeline-hide-mode
    "Minor mode to hide the mode-line in the current buffer."
    :init-value nil
    :global nil
    (if aero/modeline-hide-mode
        (progn
          (add-hook 'after-change-major-mode-hook #'aero/modeline-hide-mode nil t)
          (unless aero/modeline-hide--old-format
            (setq aero/modeline-hide--old-format mode-line-format))
          (setq mode-line-format nil))
      (remove-hook 'after-change-major-mode-hook #'aero/modeline-hide-mode t)
      (setq mode-line-format aero/modeline-hide--old-format
            aero/modeline-hide--old-format nil))
    (when (called-interactively-p 'any)
      (redraw-display)))
#+END_SRC

And now we actually turn it on everywhere. Except we hide it in eshell for a more sleek interface.

#+BEGIN_SRC emacs-lisp :lexical t
  (aero/modeline-global-mode +1)
  (add-hook 'eshell-mode-hook 'aero/modeline-hide-mode)
#+END_SRC

** Theme (Aero theme)
My custom theme, stored as a submodule. Also sets the font.

Sets the font-height to 140 only for Mac, it seems to scale normally by default in Linux.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! aero-theme :local :load-path "lib/aero-theme"
    :init
    (when (system-is-mac)
      (setq aero-theme-font-height 140))
    :config
    (setq aero-theme-font "JetBrains Mono")
    (load-theme 'aero t))
#+END_SRC

** Default frame setup
Set up the default frame in an agreeable fashion. The width is based on a buffer that's 106 columns wide, in two columns. The rest has been tweaked over the years to look extra nice on startup.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq default-frame-alist
        (append (list '(width  . 212) '(height . 62)
                      '(tool-bar-lines . 0)
                      '(menu-bar-lines . 0)
                      '(internal-border-width . 8)
                      '(left-fringe . 8) '(right-fringe . 8)
                      '(vertical-scroll-bars . nil)
                      '(ns-transparent-titlebar . t))))
  (split-window-horizontally)
  (if (fboundp 'fringe-mode) (fringe-mode '8))
  (set-frame-parameter (selected-frame) 'internal-border-width 8)
  (when (fboundp 'pixel-scroll-precision-mode)
    (pixel-scroll-precision-mode +1))

  (setq window-divider-default-right-width 1
        window-divider-default-bottom-width 1
        window-divider-default-places 'right-only
        window-divider-mode t)
#+END_SRC

Set up window margins

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'window-configuration-change-hook
            (lambda ()
              (set-window-margins
               (car (get-buffer-window-list (current-buffer) nil t)) 1 1)))
#+END_SRC

Make sure new frames use window-divider

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'before-make-frame-hook 'window-divider-mode)
#+END_SRC

** General UI
Better fringe symbols

#+BEGIN_SRC emacs-lisp :lexical t
  (when (and (require 'disp-table nil 'noerror) standard-display-table)
    (set-display-table-slot standard-display-table 'truncation ?…)
    (set-display-table-slot standard-display-table 'wrap ?↩)
    (set-display-table-slot standard-display-table 'selective-display
                            (string-to-vector " …")))
#+END_SRC

Stop cursor blinking, highlight matching parens, smooth scrolling, and highlight the current line.

#+BEGIN_SRC emacs-lisp :lexical t
  (blink-cursor-mode 0)
  (show-paren-mode 1)
  (pixel-scroll-mode 1)
  (global-hl-line-mode +1)

  (defun aero/suggest-other-faces (func &rest args)
    "When hl-line-mode is active, suggest a face calculated without it.
     Credit: Sacha Chua"
    (if global-hl-line-mode
        (progn
          (global-hl-line-mode -1)
          (prog1 (apply func args)
            (global-hl-line-mode 1)))
      (apply func args)))
  (advice-add #'face-at-point :around #'aero/suggest-other-faces)
#+END_SRC

Simple rainbow mode to highlight hex colors in code.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/rainbow-mode ()
    "Display colors represented as hex values."
    (interactive)
    (remove-overlays (point-min) (point-max))
    (let ((hex-color-regex "#[0-9a-fA-F]\\{3,6\\}"))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward hex-color-regex nil t)
          (let* ((color (match-string 0))
                 (overlay (make-overlay (match-beginning 0) (match-end 0))))
            (if (string-greaterp color "#888888")
                (overlay-put overlay 'face `(:background ,color :foreground "black"))
              (overlay-put overlay 'face `(:background ,color :foreground "white"))))))))
  (defun aero/rainbow-mode-disable ()
    "Remove all hex color overlays in the current buffer."
    (interactive)
    (remove-overlays (point-min) (point-max)))
  (add-hook 'prog-mode-hook #'aero/rainbow-mode)
  (add-hook 'org-mode-hook #'aero/rainbow-mode)
  (add-hook 'conf-space-mode-hook #'aero/rainbow-mode)
#+END_SRC

Makes links in comments clickable

#+BEGIN_SRC emacs-lisp :lexical t
  (global-goto-address-mode +1)
#+END_SRC

Pulse the current line when changing windows. There's whole packages that do this functionality and more, but I only care about switching windows, so there's no need to pull in a whole package.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun pulse-line (&rest _)
    "Briefly pulse a highlight of the line at point.
  This function, when bound to certain commands like scrolling, acts as a native
  alternative to the beacon package."
    (pulse-momentary-highlight-one-line (point)))
  (dolist (fn '(other-window
                windmove-up
                windmove-down
                windmove-left
                windmove-right
                aero/alternate-buffer
                aero/alternate-window))
    (advice-add fn :after #'pulse-line))
#+END_SRC

** Good scroll
Improved pixel-based smooth scrolling. Mostly used when screen sharing, doesn't really do much for normal navigation.

Setting =good-scroll-avoid-vscroll-reset= to nil avoids a bug with evil-mode. https://github.com/io12/good-scroll.el/issues/16

#+BEGIN_SRC emacs-lisp :lexical t
  (package! good-scroll "io12/good-scroll.el"
    :functions (good-scroll-mode)
    :init (setq good-scroll-avoid-vscroll-reset nil)
    :config (good-scroll-mode +1))
#+END_SRC

** Formfeeder
Displays formfeed characters, which are often used by convention in Elisp

#+BEGIN_SRC emacs-lisp :lexical t
  (package! formfeeder "thornjad/formfeeder"
    :defines (formfeeder-line-width)
    :config
    (setq formfeeder-line-width (- fill-column 1))
    (declare-function global-formfeeder-mode "formfeeder.el")
    (global-formfeeder-mode 1))
#+END_SRC

** Highlight-thing
Highlight the current thing at point, kind of like what lsp-ui does for some languages, but in all buffers and modes.

We set =highlight-thing-limit-to-region-in-large-buffers= so that in large buffers, only look at nearby lines


#+BEGIN_SRC emacs-lisp :lexical t
  (package! highlight-thing (:host github :repo "fgeller/highlight-thing.el")
    :hook (prog-mode . highlight-thing-mode)
    :commands (highlight-thing-mode)
    :custom
    (highlight-thing-delay-seconds 0.5)
    (highlight-thing-narrow-region-lines 70)
    (highlight-thing-large-buffer-limit 5000)
    (highlight-thing-limit-to-region-in-large-buffers-p t))
#+END_SRC

** Selection highlight
Shows all matching selections from region. Very useful for comparing and editing multiple instances of the same thing.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! selection-highlight-mode
    (:host github :repo "balloneij/selection-highlight-mode")
    :hook (prog-mode . selection-highlight-mode)
    :custom (selection-highlight-mode-min-length 3))
#+END_SRC

** Todo-light
Highlight todo and similar words

#+BEGIN_SRC emacs-lisp :lexical t
  (package! todo-light "thornjad/todo-light"
    :init (global-todo-light-mode +1))
#+END_SRC

** Evil-terminal-cursor-changer
Doesn't do anything for GUI, so don't bother. In TUI, use a line when in insert mode

#+BEGIN_SRC emacs-lisp :lexical t
  (unless (display-graphic-p)
    (package! evil-terminal-cursor-changer
      (:host github :repo "7696122/evil-terminal-cursor-changer")
      :after evil
      :functions (evil-terminal-cursor-changer-activate)
      :config (evil-terminal-cursor-changer-activate)))
#+END_SRC

* Breadcrumbs in the headerline
Shows breadcrumbs in the headerline for many modes, showing the "trail" that the current point sits in, such as the hierarchy of headers in org-mode or the class and method in object-oriented languages.

Breadcrumbs are disabled for gptel since it uses its own system.

#+BEGIN_SRC emacs-lisp
  (cl-defun aero-breadcrumb--bisect (a x &key (from 0) (to (length a)) key from-end)
    "Compute index to insert X in sequence A, keeping it sorted.
    If X already in A, the resulting index is the leftmost such
    index, unless FROM-END is t.  KEY is as usual in other CL land."
    (cl-macrolet ((search (from-end key)
                          `(cl-loop while (< from to)
                                    for mid = (/ (+ from to) 2)
                                    for p1 = (elt a mid)
                                    for p2 = ,(if key `(funcall key p1) `p1)
                                    if (,(if from-end '< '<=) x p2)
                                    do (setq to mid) else do (setq from (1+ mid))
                                    finally return from)))
      (if from-end (if key (search t key) (search t nil))
        (if key (search nil key) (search nil nil)))))

  (defun aero-breadcrumb--ipath-rich (index-alist pos)
    "Compute ipath for rich `imenu--index-alist' structures.
    These structures have a `aero-breadcrumb-region' property on every
    node."
    (cl-labels
        ((search (nodes &optional ipath)
                 (cl-loop
                  for n in nodes
                  for reg = (get-text-property 0 'aero-breadcrumb-region (car n))
                  when (<= (car reg) pos (cdr reg))
                  return (search (cdr n) (cons
                                          (propertize (car n)
                                                      'aero-breadcrumb-siblings nodes
                                                      'aero-breadcrumb-parent (car ipath))
                                          ipath))
                  finally (cl-return ipath))))
      (nreverse (search index-alist))))

  (defvar-local aero-breadcrumb--ipath-plain-cache nil
    "A cache for `aero-breadcrumb--ipath-plain'.")

  (defun aero-breadcrumb--ipath-plain (index-alist pos)
    "Compute ipath for plain `imenu--index-alist' structures.
    These structures don't have a `aero-breadcrumb-region' property on."
    (cl-labels ((dfs (n &optional ipath siblings)
                     (setq ipath (cons (car n) ipath))
                     (if (consp (cdr n))
                         (mapc (lambda (n2) (dfs n2 ipath (cdr n))) (cdr n))
                       (put-text-property 0 1 'aero-breadcrumb-siblings (cdr siblings) (car ipath))
                       (setq aero-breadcrumb--ipath-plain-cache
                             (vconcat aero-breadcrumb--ipath-plain-cache
                                      `[,(cons
                                          (cl-etypecase (cdr n)
                                            (number (cdr n))
                                            (marker (+ (cdr n) 0))
                                            (overlay (overlay-start (cdr n))))
                                          ipath)])))))
      (unless aero-breadcrumb--ipath-plain-cache
        (mapc (lambda (i) (dfs i nil index-alist)) index-alist)
        (setq aero-breadcrumb--ipath-plain-cache (cl-sort aero-breadcrumb--ipath-plain-cache #'< :key #'car)))
      (unless (< pos (car (aref aero-breadcrumb--ipath-plain-cache 0)))
        (let ((res (aero-breadcrumb--bisect aero-breadcrumb--ipath-plain-cache pos :key #'car :from-end t)))
          (unless (zerop res) (reverse (cdr (elt aero-breadcrumb--ipath-plain-cache (1- res)))))))))

  (defun aero-breadcrumb-ipath (index-alist pos)
    "Get aero-breadcrumb for position POS given INDEX-ALIST."
    (if (get-text-property 0 'aero-breadcrumb-region (caar index-alist))
        (aero-breadcrumb--ipath-rich index-alist pos)
      (aero-breadcrumb--ipath-plain index-alist pos)))

  (defvar aero-breadcrumb-idle-time 1
    "Control idle time before requesting new aero-breadcrumbs.")

  (defvar-local aero-breadcrumb--idle-timer nil
    "Timer used by `aero-breadcrumb--ipath-alist'.")

  (defvar-local aero-breadcrumb--last-update-tick 0
    "Last time `aero-breadcrumb--ipath-alist' asked for an update.")

  (defun aero-breadcrumb--ipath-alist ()
    "Return `imenu--index-alist', maybe arrange for its update."
    (let ((nochangep (= (buffer-chars-modified-tick) aero-breadcrumb--last-update-tick))
          (buf (current-buffer)))
      (unless nochangep
        (setq aero-breadcrumb--last-update-tick (buffer-chars-modified-tick))
        (when aero-breadcrumb--idle-timer (cancel-timer aero-breadcrumb--idle-timer))
        (setq aero-breadcrumb--idle-timer
              (run-with-idle-timer
               aero-breadcrumb-idle-time nil
               (lambda ()
                 (when (buffer-live-p buf)
                   (with-current-buffer buf
                     (setq aero-breadcrumb--last-update-tick (buffer-chars-modified-tick))
                     (let ((non-essential t)
                           (imenu-auto-rescan t))
                       (ignore-errors
                         (imenu--make-index-alist t))
                       (setq aero-breadcrumb--ipath-plain-cache nil)
                       (when (get-buffer-window buf t)
                         (force-mode-line-update t)))))))))
      imenu--index-alist))

  (defun aero-breadcrumb--length (len)
    "Interpret LEN using `window-width' and return a number."
    (cond ((floatp len) (* (window-width) len))
          (t len)))

  (defun aero-breadcrumb--format-ipath-node (p more)
    (propertize p 'face (if more
                            '(:inherit shadow)
                          '(:inherit (font-lock-function-name-face shadow)))
                'aero-breadcrumb-dont-shorten (null more)))

  (defun aero-breadcrumb-crumbs ()
    "Describe point inside the Imenu tree of current file."
    (when-let ((alist (aero-breadcrumb--ipath-alist)))
      (when (cl-some #'identity alist)
        (aero-breadcrumb--summarize
         (cl-loop
          for (p . more) on (aero-breadcrumb-ipath alist (point))
          collect (aero-breadcrumb--format-ipath-node p more))
         (aero-breadcrumb--length 0.98)
         (propertize " > " 'face '(:inherit shadow))))))

  (defun aero-breadcrumb--summarize (crumbs cutoff separator)
    "Return a string that summarizes CRUMBS, a list of strings.
    \"Summarization\" consists of truncating some CRUMBS to 1
    character.  Rightmost members of CRUMBS are summarized last.
    Members with a `aero-breadcrumb-dont-shorten' are never truncated.
    Aim for a return string that is at most CUTOFF characters long.
    Join the crumbs with SEPARATOR."
    (let ((rcrumbs
           (cl-loop
            for available = (- cutoff used)
            for (c . more) on (reverse crumbs)
            for seplen = (if more (length separator) 0)
            for shorten-p = (unless (get-text-property 0 'aero-breadcrumb-dont-shorten c)
                              (> (+ (length c) seplen) available))
            for toadd = (if shorten-p (substring c 0 1) c)
            sum (+ (length toadd) seplen) into used
            collect toadd)))
      (string-join (reverse rcrumbs) separator)))

  (defun aero-breadcrumb--header-line ()
    "Helper for `aero-breadcrumb-headerline-mode'."
    (let ((x (cl-remove-if #'seq-empty-p (mapcar #'funcall '(aero-breadcrumb-crumbs)))))
      (mapconcat #'identity x (propertize " : " 'face '(:inherit shadow)))))

  (define-minor-mode aero-breadcrumb-local-mode
    "Header lines with aero-breadcrumbs."
    :init-value nil
    (if aero-breadcrumb-local-mode (add-to-list 'header-line-format '(:eval (aero-breadcrumb--header-line)))
      (setq header-line-format (delete '(:eval (aero-breadcrumb--header-line)) header-line-format))))
#+END_SRC

Now we set up the hooks, but also disable for gptel (which uses markdown-mode in this config).

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'prog-mode-hook #'aero-breadcrumb-local-mode)
  (add-hook 'markdown-mode-hook #'aero-breadcrumb-local-mode)
  (add-hook 'gfm-mode-hook #'aero-breadcrumb-local-mode)
  (add-hook 'org-mode-hook #'aero-breadcrumb-local-mode)

  (with-eval-after-load 'gptel
    (add-hook 'gptel-mode-hook (lambda () (aero-breadcrumb-local-mode -1))))
#+END_SRC

* Project management
Nearly all my code is organized within projects, and navigated using this built-in package.

Note that we can't use =:hook= for the =project-find-functions= because =project-find-functions= doesn't end in "-hook", and we can't use this in =:init= because it won't be defined yet.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! project :builtin
    :after (general)

    :preface
    (defun aero/project-root-override (dir)
      "Find DIR's project root by searching for a '.project.el' file.

  If this file exists, it marks the project root. For convenient compatibility with Projectile,
  '.projectile' is also considered a project root marker.

  https://jmthornton.net/blog/p/emacs-project-override"
      (let ((root (or (locate-dominating-file dir ".project.el")
                      (locate-dominating-file dir ".projectile")))
            (backend (ignore-errors (vc-responsible-backend dir))))
        (when root (if (version<= emacs-version "28")
                       (cons 'vc root)
                     (list 'vc backend root)))))

    (defun aero/project-switch-magit ()
      "Call magit-status on the project being switched to."
      (interactive)
      (magit-status project-current-directory-override))

    :custom
    (project-vc-ignores '("node_modules/" "straight/" "target/")) ; globally ignored
    (project-vc-extra-root-markers '(".project.el" ".projectile" ".git"))
    (project-compilation-buffer-name-function #'project-prefixed-buffer-name)

    :config
    (add-hook 'project-find-functions #'aero/project-root-override)
    (setq project-switch-commands '((project-find-file "Find file" "f")
                                    (aero/project-switch-magit "Magit status" "g")
                                    (project-eshell "Eshell" "e")
                                    (project-compile "Compile" "c")
                                    (project-find-dir "Find directory" "d")
                                    (project-find-regexp "Find regexp" "r")
                                    (project-any-command "Any command" "a")))

    (aero-leader-def
      "pf" 'project-find-file
      "pp" 'project-switch-project
      "p:" 'project-shell-command
      "p&" 'project-async-shell-command
      "p'" 'project-eshell
      "p\"" 'aero/project-eshell-new
      "p`" 'project-shell
      "p%" 'project-query-replace-regexp
      "cp" 'project-compile))
#+END_SRC

* Magit
One of the truly great packages in Emacs. I use it for everything git-related.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! magit :auto
    :after (general)
    :commands (magit-blame
               magit-commit
               magit-diff-unstaged
               magit-init
               magit-stage-file
               magit-status
               magit-unstage-file
               magit-blame-mode)
    :init
    (aero-leader-def
      "gs" 'magit-status
      "gb" 'magit-blame
      "gl" '(:ignore t :which-key "log")
      "glb" 'magit-log-buffer-file
      "gld" 'magit-log-trace-definition
      "gll" 'magit-log-head
      "gfS" 'magit-stage-file
      "gfU" 'magit-unstage-file
      "gm" '(:ignore t :which-key "smerge")
      "gmm" 'smerge-start-session
      "gmu" 'smerge-keep-upper
      "gml" 'smerge-keep-lower
      "gmn" 'smerge-next
      "gmp" 'smerge-prev
      "gma" 'smerge-keep-all
      "gmE" 'smerge-ediff)

    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1)
    (magit-process-finish-apply-ansi-colors t)
    (magit-buffer-name-format "%x%M%v: %t%x")
    (magit-list-refs-sortby "-creatordate")
    (magit-diff-paint-whitespace-lines 'both)
    (magit-diff-refine-hunk 'all)
    (magit-diff-refine-ignore-whitespace t)
    (git-commit-style-convention-checks '(non-empty-second-line overlong-summary-line))
    (git-commit-summary-max-length 50)
    (git-commit-fill-column 72)

    :config
    (add-hook 'with-editor-mode-hook #'evil-insert-state)
    (magit-auto-revert-mode nil)

    (defun aero/truncate-lines-off () (toggle-truncate-lines -1))
    (add-hook 'magit-status-mode-hook #'aero/truncate-lines-off)

    (defun aero/magit-switch-to-diff () (other-window 1))
    (advice-add 'magit-diff :after #'aero/magit-switch-to-diff)

    (defun aero/magit-diff-default-branch (&optional args)
      "Show diff of default branch to working tree."
      (interactive (list (magit-diff-arguments)))
      (magit-diff-working-tree
       (replace-regexp-in-string "refs/remotes/origin/" ""
                                 (magit-git-string "symbolic-ref" "refs/remotes/origin/HEAD"))
       args))

    (defun aero/magit--color-buffer (proc &rest args)
      (interactive)
      (with-current-buffer (process-buffer proc)
        (read-only-mode -1)
        (ansi-color-apply-on-region (point-min) (point-max))
        (read-only-mode 1)))
    (advice-add 'magit-process-filter :after #'aero/magit--color-buffer)

    (defun aero/fetch-pr ()
      "Fetch a GH(E) pull request into a new branch prefixed with `pr'."
      (interactive)
      (let* ((pr (message-read-from-minibuffer "Enter PR number: "))
             (new-branch (format "pr%s" pr))
             (fetch-command
              (format "git fetch origin pull/%s/head:%s" pr new-branch)))
        (shell-command fetch-command)
        (magit-status)
        (message "Checked out PR as %s" new-branch))))
#+END_SRC

** git-gutter
Provides a visual indicator of changes in the gutter. I use it to quickly see what's changed in a file. The backends is set to git by default, and only loads the others if they actually exist on the system, which they never do.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! git-gutter :auto
    :hook ((prog-mode text-mode conf-mode) . git-gutter-mode)
    :custom
    (git-gutter:visual-line t)
    (git-gutter:disabled-modes '(so-long-mode
                                 image-mode asm-mode
                                 doc-view-mode
                                 fundamental-mode image-mode pdf-view-mode))
    (git-gutter:update-interval 0.02)
    (git-gutter:handled-backends
     (cons 'git (cl-remove-if-not #'executable-find (list 'hg 'svn 'bzr)
                                  :key #'symbol-name)))

    :config
    (add-hook 'focus-in-hook #'git-gutter:update-all-windows))
#+END_SRC

*** git-gutter-fringe
Redefine the fringe bitmap definer to a no-op in GUI, if it's not already bound, otherwise git-gutter-fringe will error. I've never tracked down the real cause, but this makes things work smoothly.

#+BEGIN_SRC emacs-lisp :lexical t
  (when (display-graphic-p)
    (unless (fboundp 'define-fringe-bitmap)
      (defun define-fringe-bitmap (bitmap &rest _)
        "This is a no-op placeholder function."
        ;; Return the symbol, just like the normal function does.
        bitmap))
#+END_SRC

The actual package, which moves the git-gutter functionality to the buffer fringe where it doesn't push text around.

The fringe bitmaps are a thin bar, expecting the theme to give them suitable coloring. The functionality is disabled in Tramp because it hogs the connection bandwidth.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! git-gutter-fringe :auto :after (git-gutter)
    :custom
    (fringes-outside-margins t)

    :config
    (define-fringe-bitmap 'git-gutter-fr:added [224]
      nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:modified [224]
      nil nil '(center repeated))
    (define-fringe-bitmap 'git-gutter-fr:deleted
      [0 0 0 0 0 0 0 0 0 0 0 0 0 128 192 224 240 248]
      nil nil 'bottom)

    (defun git-gutter-find-file-hook ()
      (git-gutter-mode
       (if (file-remote-p (buffer-file-name))
           0
         1)))
    (add-hook 'find-file-hook #'git-gutter-find-file-hook)))
#+END_SRC

** Ediff
A decent way to compare diffs. I've set it up to split horizontally and use a plain window setup.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! ediff :builtin
    :commands (ediff ediff3)
    :custom
    (ediff-split-window-function #'split-window-horizontally )
    (ediff-window-setup-function #'ediff-setup-windows-plain))
#+END_SRC

** Git-link
Super simple way to get a link to a file or line in a file on GitHub

#+BEGIN_SRC emacs-lisp :lexical t
  (package! git-link :auto
    :after (general)
    :commands (git-link git-link-commit git-link-homepage)
    :init (aero-leader-def "gL" 'git-link))
#+END_SRC

* Org mode and org agenda
Org is an incredibly powerful tool in Emacs, and I make the most use of it for task management and note-taking.

** Org helper functions
Before the actual package config, let's define some useful functions.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun archive-buffer-closed-tasks ()
    (interactive)
    (org-map-entries
     (lambda ()
       (when (member (org-get-todo-state) org-done-keywords)
         (org-archive-subtree-default)
         ;; the archive alters the tree, so just go back to the top
         (setq org-map-continue-from (point-min))))
     nil 'file))

  (defun trim-archive-entries ()
    "Trim entries in the archive file older than 60 days."
    (interactive)
    (let ((archive-file (expand-file-name aero/thornlog-archive-file)))
      (when (file-exists-p archive-file)
        (let ((cutoff-date (time-subtract (current-time) (days-to-time 60))))
          (with-current-buffer (find-file-noselect archive-file)
            (goto-char (point-min))
            (while (not (eobp))
              (when (and (org-at-heading-p)
                         (let ((archive-time-str (org-entry-get (point) "ARCHIVE_TIME")))
                           (and archive-time-str
                                (time-less-p (org-read-date nil t archive-time-str) cutoff-date))))
                (org-cut-subtree)
                (org-back-to-heading t)
                (outline-previous-heading))
              (outline-next-heading)))
          (save-buffer)))))

  (defun aero/org-archive-cleanup ()
    "Archive closed tasks and trim archive entries."
    (interactive)
    (archive-buffer-closed-tasks)
    (trim-archive-entries))

  (defun aero/org-collapse-entry-if-done ()
    "Collapse the current entry if it is marked as DONE."
    (when (member org-state '("DONE"))
      (hide-subtree)))

  (defun aero/org-expand-entry-if-todo ()
    "Expand the current entry if it is marked as TODO."
    (when (member org-state '("TODO"))
      (show-subtree)))

  (defun jump-to-org-agenda ()
    "Go to the org agenda. Used on idle timer."
    (interactive)
    (let ((buf (get-buffer "*Org Agenda*"))
          wind)
      (if buf
          (if (setq wind (get-buffer-window buf))
              (select-window wind)
            (if (called-interactively-p 'any)
                (progn
                  (select-window (display-buffer buf t t))
                  (org-fit-window-to-buffer))
              (with-selected-window (display-buffer buf)
                (org-fit-window-to-buffer))))
        (call-interactively 'org-agenda-list))))

  (defun aero/org-insert-modified-timestamp-now ()
    "Insert a modified property with the current time."
    (interactive)
    (org-set-property "modified" (format-time-string "[%Y-%m-%d %a %H:%M]")))
#+END_SRC

Reordering is based on https://ag91.github.io/blog/2022/03/12/org-agenda-keep-the-buffer-order-untouched-after-saving-all-modified-org-buffers/

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/reorder-buffer-list (new-list)
    (while new-list
      (bury-buffer (car new-list))
      (setq new-list (cdr new-list))))

  (defun aero/keep-buffer-list-unaltered (orig-fun &rest args)
    (let ((buffers (buffer-list))
          (result (apply orig-fun args)))
      (aero/reorder-buffer-list buffers)
      result))

  (defun org-schedule-and-refile ()
    "Schedule the current entry and refile it."
    (interactive)
    (org-schedule t)
    (org-refile))

  (defun org-deadline-and-refile ()
    "Deadline the current entry and refile it."
    (interactive)
    (org-deadline t)
    (org-refile))

  (defun aero/org-agenda-format-date (date)
    "Format a DATE string for display in the daily/weekly agenda.
  This function makes sure that dates are aligned for easy reading."
    (require 'cal-iso)
    (let* ((dayname (calendar-day-name date))
  	       (day (cadr date))
  	       (month (car date))
  	       (monthname (calendar-month-name month))

           ;; divisor must be float so (/) doesn't do integer division
           (quarter (round (/ (1+ month) 3.0)))

  	       (year (nth 2 date))
  	       (iso-week (org-days-to-iso-week
  		                (calendar-absolute-from-gregorian date)))
  	       (day-of-week (calendar-day-of-week date))
  	       (weekstring (if (= day-of-week 1)
  			                   (format " W%02d" iso-week)
  		                   "")))
      (format "%-10s %2d %s %4d%s   (Q%s)"
  	          dayname day monthname year weekstring quarter)))

  (defun aero/org-deindent-on-return (&rest _)
    "De-indent the current line if there is only whitespace before the point when pressing ENTER.

  This behavior is IDIOTIC and I cannot suffer to live with this automatic indentation any longer."
    (when (and (derived-mode-p 'org-mode)
               (save-excursion
                 (move-beginning-of-line 1)
                 (looking-at-p "[ \t]*$")))
      (delete-horizontal-space)))
#+END_SRC

*** Org formatting helpers
Call on region or line at point to apply formatting markers

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-apply-format (prefix suffix)
    "Apply the specified PREFIX and SUFFIX to the active region or current line.
  If there is an active region, wrap it directly. If there is no active region,
  apply to the current line, ignoring leading whitespace."
    (interactive "sPrefix: \nsSuffix: ")
    (let* ((use-region (region-active-p))
           (beg (if use-region
                    (region-beginning)
                  (save-excursion
                    (beginning-of-line)
                    (skip-chars-forward " \t") ; ignore leading whitespace
                    (point))))
           (end (if use-region
                    (region-end)
                  (line-end-position)))
           (text (buffer-substring-no-properties beg end)))
      (delete-region beg end)
      (insert (concat prefix text suffix))))

  (defun aero/org-apply-bold ()
    "Wrap region or line in Org *bold* markers."
    (interactive)
    (aero/org-apply-format "*" "*"))

  (defun aero/org-apply-italic ()
    "Wrap region or line in Org /italic/ markers."
    (interactive)
    (aero/org-apply-format "/" "/"))

  (defun aero/org-apply-strike-through ()
    "Wrap region or line in Org +strike-through+ markers."
    (interactive)
    (aero/org-apply-format "+" "+"))

  (defun aero/org-apply-verbatim ()
    "Wrap region or line in Org =verbatim= markers."
    (interactive)
    (aero/org-apply-format "=" "="))

  (defun aero/org-apply-code ()
    "Wrap region or line in Org ~code~ markers."
    (interactive)
    (aero/org-apply-format "~" "~"))
#+END_SRC

** Org package
Now for the actual package configuration. This is a long one, so I've made a lot of comments within the code block rather than putting everything up here.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org :builtin
    :preface

    :custom
    (org-hide-leading-stars t)
    (org-pretty-entities t)
    (org-indent-mode-turns-on-hiding-stars nil) ; why would this even exist??
    (org-fontify-quote-and-verse-blocks t)
    (org-insert-heading-respect-content t) ; insert headings after current subtree
    (org-fold-catch-invisible-edits 'smart) ; don't accidentally remove hidden text
    (org-startup-with-inline-images t) ; default to showing images on startup
    (org-startup-indented t)
    (org-log-done 'time) ; log time when item is marked done
    (org-log-into-drawer t) ; put logs in LOGBOOK
    (org-refile-use-outline-path t) ; show path to outline level during refile
    (org-fontify-done-headline t) ; let theme strike out done items
    (org-return-follows-link t) ; follow links with RET

    ;; always put blank before new headings, but be smart about list items
    (org-blank-before-new-entry '((heading . t) (plain-list-item . auto)))

    ;; re-scale images to 400px if no with attribute is set (see
    ;; https://lists.gnu.org/archive/html/emacs-orgmode/2012-08/msg01402.html)
    (org-image-actual-width '(400))

    (org-capture-templates
     `(("t" "Deadline/Scheduled Task" entry
        (file+headline
         ,(expand-file-name "todo.org" aero/roam-path)
         "Tasks")
        "* TODO [#C] %?\nSCHEDULED: %t\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n"
        :empty-lines 1)
       ("p" "Ticket (PR)" entry
        (file+headline
         ,(expand-file-name "todo.org" aero/roam-path)
         "Tasks")
        "* TICKET [#C] %?\nSCHEDULED: %t\n:PROPERTIES:\n:CREATED: %U\n:END:\n"
        :empty-lines 1)
       ("r" "Review (PR or tech design)" entry
        (file+headline
         ,(expand-file-name "todo.org" aero/roam-path)
         "Tasks")
        "* REVIEW [#B] %? :review:\nSCHEDULED: %t DEADLINE: %t\n:PROPERTIES:\n:CREATED: %U\n:END:\nLink: "
        :empty-lines 1)
       ("s" "School inbox item" entry
        (file+headline
         ,(expand-file-name "school_todo.org" aero/roam-path)
         "Tasks")
        "* TODO [#C] %?\nSCHEDULED: %t\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n"
        :empty-lines 1)))

    (org-todo-keywords
     '((sequence "TODO(t)" "WAITING(w!)" "BLOCKED(b!)" "BACKLOG(l!)" "|" "DONE(d!)" "REMOVED(k)")
       (sequence "TICKET(T)" "PR(p!)" "|" "DONE(d!)" "CLOSED(x)")
       (sequence "REVIEW(r)" "WAITING(w!)" "BLOCKED(b!)" "|" "DONE(d!)" "CLOSED(x)")))

    (org-use-fast-todo-selection 'expert) ; don't fuck up the window layout
    (org-default-notes-file (expand-file-name "notes_inbox.org" aero/roam-path))
    (org-priority-faces '((?A . error)
                          (?B . warning)
                          (?C . success)
                          (?D . success)
                          (?E . org-priority)
                          (?F . org-priority)))
    (org-priority-highest ?A)
    (org-priority-lowest ?F) ; default is C, tasks default to C
    (org-reverse-note-order nil) ; put notes at the end of the entry, instead of the top
    (org-archive-location (concat aero/thornlog-archive-file "::* From %s"))

    ;; When editing a source block in its own mode, don't mess with windows at all
    (org-src-window-setup 'current-window)

    ;; don't consider empty lines between entries to be part of the entry
    (org-cycle-separator-lines -2)

    (org-link-frame-setup '((vm . vm-visit-folder-other-frame)
                            (vm-imap . vm-visit-imap-folder-other-frame)
                            (gnus . org-gnus-no-new-news)
                            (file . find-file)
                            (wl . wl-other-frame)))

    ;; Agenda
    (org-agenda-span 1) ; days to show at a time
    (org-agenda-start-day nil) ; day to start at
    (org-agenda-start-on-weekday nil) ; start week on current day
    (org-agenda-format-date #'aero/org-agenda-format-date)
    (org-agenda-prefix-format '((agenda . " %i %?-12t% s")
                                (todo . " %i %-12:c")
                                (tags . " %i %-12:c")
                                (search . " %i %-12:c")))

    ;; all agenda files
    (org-agenda-files `(,(expand-file-name "todo.org" aero/roam-path)
                        ,(expand-file-name "school_todo.org" aero/roam-path)
                        ,(expand-file-name "log.org" aero/roam-path)
                        ,(expand-file-name "ritual.org" aero/roam-path)
                        ,(expand-file-name "holidays.org" aero/roam-path)
                        ,(expand-file-name "notes_inbox.org" aero/roam-path)))

    ;; holidays I don't want to display
    (holiday-bahai-holidays nil)
    (holiday-hebrew-holidays nil)
    (holiday-islamic-holidays nil)
    (holiday-christian-holidays nil)
    (holiday-oriental-holidays nil)

    ;; local holidays
    (holiday-local-holidays '((holiday-fixed 3 14 "Pi Day")
                              (holiday-fixed 10 23 "Mole Day")
                              (holiday-fixed 11 23 "Fibonacci Day")
                              (holiday-fixed 12 23 "Festivus")
                              (holiday-fixed 9 19 "Talk Like a Pirate Day")
                              (holiday-fixed 10 9 "Leif Erikson Day")
                              (holiday-fixed 5 4 "Star Wars Day")
                              (holiday-fixed 6 28 "Tau Day")

                              (holiday-fixed 2 27 "Hangover (first day)")
                              (holiday-fixed 2 28 "Hangover (second day)")
                              (holiday-fixed 2 29 "Hangover (third day)")
                              (holiday-fixed 3 1 "Hangover (fourth day)")
                              (holiday-fixed 3 2 "Hangover (fifth day)")
                              (holiday-fixed 3 3 "Hangover (sixth day)")
                              (holiday-fixed 3 4 "Hangover (seventh day)")
                              (holiday-fixed 3 5 "Hangover (eighth day)")
                              (holiday-fixed 3 6 "The Day of the Dude")))

    (org-agenda-log-mode-items nil) ; don't show closed nor clocked items
    (org-agenda-tags-column -70) ; shift tags over
    (org-agenda-sticky nil) ; don't bury on close buffer
    (org-agenda-use-tag-inheritance t)
    (org-agenda-show-log t)
    (org-agenda-skip-deadline-if-done t)
    (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
    (org-agenda-skip-scheduled-if-done t)
    (org-agenda-skip-scheduled-if-deadline-is-shown t) ; don't duplicate deadline & scheduled
    (org-agenda-skip-timestamp-if-done t)
    (org-agenda-skip-timestamp-if-deadline-is-shown t)
    (org-agenda-window-setup 'current-window) ; stop agenda opening a new window
    (org-agenda-skip-unavailable-files t)
    (org-agenda-show-future-repeats nil) ; don't show repeating tasks on future agenda dates
    (org-agenda-custom-commands
     `(("n" "Agenda and all TODOs" ((agenda "") (alltodo "")))
       ("s" "School items" agenda ""
        ((org-agenda-files '(,(expand-file-name "school_todo.org" aero/roam-path)))))
       ("e" "Experimentation tag" tags "experimentation")))

    :init
    (aero-leader-def
      "oa" '(aero/org-agenda-list :wk "agenda")
      "oc" '(aero/org-class-agenda-list :wk "class agenda")
      "oA" '(org-agenda :wk "agenda menu")
      "os" 'org-schedule
      "od" 'org-deadline
      "oj" 'org-clock-goto
      "ot" 'aero/org-set-tags
      "ol" 'org-store-link
      "oT" '(org-tags-view :wk "list tags")
      "vo" 'org-capture)

    :config
    (aero-mode-leader-def
      :keymaps 'org-mode-map
      "t" 'org-todo
      "f" 'org-forward-heading-same-level
      "F" 'org-backward-heading-same-level
      "w" 'org-open-at-point
      "p" 'org-priority
      "r" 'org-refile
      "s" 'org-set-property
      "e" 'org-edit-src-code
      "d" 'insert-new-day
      "i" '(:ignore t :wk "insert")
      "il" 'org-insert-link
      "it" 'org-time-stamp
      "ii" 'org-insert-structure-template
      "id" '(org-insert-drawer :wk "drawer")
      "im" 'insert-meeting-task
      "A" 'aero/org-archive-cleanup
      "c" '(:ignore t :wk "clock / cell")
      "cc" '(org-babel-execute-src-block :wk "exec cell")
      "cs" 'org-babel-demarcate-block)

    (aero-mode-leader-def
      :keymaps 'org-src-mode-map
      "q" 'org-edit-src-exit
      "w" 'org-edit-src-save
      "X" 'org-edit-src-abort)

    ;; keep org-save-all from messing up buffer list
    (advice-add 'org-save-all-org-buffers :around #'aero/keep-buffer-list-unaltered)

    ;; org tries to take this binding back, so wrest control back once more
    (define-key org-mode-map (kbd "M-h") #'windmove-left)

    ;; Collapse entries when they are marked as done, and expand when reopened
    (add-hook 'org-after-todo-state-change-hook
              #'aero/org-collapse-entry-if-done)
    (add-hook 'org-after-todo-state-change-hook #'aero/org-expand-entry-if-todo)

    ;; Get rid of the idiotic indentation after pressing enter
    (advice-add 'org-return :after #'aero/org-deindent-on-return)
    (with-eval-after-load 'evil
      (advice-add 'evil-org-open-below :after #'aero/org-deindent-on-return))

    ;; When inside an org src-block (like right here), turn off fancy quotes and use normal pairing so that typing " inserts "" as expected.
    (add-hook 'org-src-mode-hook
              (lambda ()
                (electric-quote-local-mode -1)
                (electric-pair-local-mode +1)
                (define-key org-src-mode-map (kbd "C-c C-c") #'org-edit-src-exit)))

    ;; Also save after state change
    (add-hook 'org-after-todo-state-change-hook #'org-save-all-org-buffers)

    ;; start with all levels collapsed
    (add-hook 'org-mode-hook #'org-hide-block-all)

    ;; Save org files when using clock
    (add-hook 'org-clock-in-hook #'org-save-all-org-buffers)
    (add-hook 'org-clock-out-hook #'org-save-all-org-buffers)

    ;; Force org-capture to not open new windows
    (defun aero/org-capture-place-template-dont-delete-windows (oldfun &rest args)
      (cl-letf (((symbol-function 'delete-other-windows) 'ignore))
        (apply oldfun args)))
    (with-eval-after-load "org-capture"
      (advice-add 'org-capture-place-template
                  :around #'aero/org-capture-place-template-dont-delete-windows))

    ;; set up stuff for clock persistence
    (org-clock-persistence-insinuate))
#+END_SRC

** Org-appear
Show formatting markers when point is near

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-appear "awth13/org-appear"
    :custom (org-hide-emphasis-markers t)
    :hook (org-mode . org-appear-mode))
#+END_SRC

** Org present
Presentation mode for Org

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-present-prepare-slide ()
    (org-overview)
    (org-show-entry)
    (org-show-children))

  (defun aero/org-present-hook ()
    (setq-local face-remapping-alist '((default (:height 1.5) variable-pitch)
                                       (header-line (:height 4.5) variable-pitch)
                                       (org-document-title (:height 1.75) org-document-title)
                                       (org-code (:height 1.55) org-code)
                                       (org-verbatim (:height 1.55) org-verbatim)
                                       (org-block (:height 1.25) org-block)
                                       (org-block-begin-line (:height 0.7) org-block)))
    (setq header-line-format " ")
    (org-appear-mode -1)
    (org-display-inline-images)
    (org-present-hide-cursor)
    (org-present-read-only)
    (aero/modeline-hide-mode)
    (aero/org-present-prepare-slide))

  (defun aero/org-present-quit-hook ()
    (setq-local face-remapping-alist '((default variable-pitch default)))
    (setq header-line-format nil)
    (org-present-small)
    (org-remove-inline-images)
    (org-present-show-cursor)
    (org-present-read-write)
    (aero/modeline-hide-mode -1)
    (org-appear-mode 1))

  (defun aero/org-present-prev ()
    (interactive)
    (org-present-prev)
    (aero/org-present-prepare-slide))

  (defun aero/org-present-next ()
    (interactive)
    (org-present-next)
    (aero/org-present-prepare-slide))

  (package! org-present :auto
    :bind (:map org-present-mode-keymap
           ("C-c C-n" . aero/org-present-next)
           ("C-c C-p" . aero/org-present-prev))
    :hook ((org-present-mode . aero/org-present-hook)
           (org-present-mode-quit . aero/org-present-quit-hook)))
#+END_SRC

** Org-modern
Some trivial UI improvements for org files. Uses the "replace" set of stars for headings.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-modern "minad/org-modern"
    :hook ((org-mode . org-modern-mode)
           (org-agenda-finalize-hook . org-modern-agenda))
    :custom
    (org-modern-star 'replace))
#+END_SRC

** Evil-org-mode
Use evil in org, particularly in org-agenda. Also unblocks using aero-leader chords. See https://github.com/Somelauw/evil-org-mode for a list of available commands.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! evil-org-mode "Somelauw/evil-org-mode"
    :after (evil org org-super-agenda)
    :preface
    (defun aero/evil-org-agenda-mode ()
      "Shim in org-agenda evil mode."
      (require 'evil-org-agenda)
      (evil-org-agenda-set-keys))

    :hook ((org-mode . evil-org-mode)
           (org-agenda-mode . aero/evil-org-agenda-mode)))
#+END_SRC

** Org-fancy-priorities
Custom display of org priorities

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-fancy-priorities "harrybournis/org-fancy-priorities"
    :after (org)
    :hook (org-mode . org-fancy-priorities-mode)
    :custom
    (org-fancy-priorities-list '("!!" "↑" "·" "↓" "○" "_")))
#+END_SRC

** Org-super-agenda
The workhorse of my task management. This package allows me to group tasks in the agenda in a way that makes sense to me.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-super-agenda "alphapapa/org-super-agenda"
    :preface
    (defun aero/org-super-agenda-without-keymap ()
      "Stops super-agenda from overriding evil-org bindings."
      (org-super-agenda-mode)
      (setq org-super-agenda-header-map (make-sparse-keymap)))

    :hook ((org-agenda-after-show . recenter)
           (org-agenda-mode . aero/org-super-agenda-without-keymap))

    :custom
    (org-super-agenda-groups
     '((:name "Daily Routine - In Progress" :and (:todo "STARTED" :tag "ritual" :not (:time-grid t)))
       (:name "Daily Routine" :and (:tag "ritual" :not (:time-grid t)))
       (:name "Holidays" :tag "holiday" :category ("Holiday" "Anniversaries"))
       (:name "Outstanding meetings" :and (:scheduled past :tag "meeting"))
       (:time-grid t)
       (:name "Reviews to do" :and (:tag "review"
                                    :todo "REVIEW"
                                    :not (:todo ("WAITING" "BLOCKED" "BACKLOG"))))
       (:name "Support" :tag "support")
       (:name "Waiting/blocked" :todo ("WAITING" "BLOCKED"))
       (:name "Past due" :and (:deadline past :not (:todo ("WAITING" "BLOCKED"))))
       (:name "Due today" :and (:deadline today :not (:todo ("WAITING" "BLOCKED"))))
       (:name "Tickets" :todo ("TICKET"))
       (:name "Prioritized" :not (:todo ("WAITING" "BLOCKED" "BACKLOG")
                                  :tag "holiday"
                                  :category ("Holiday" "Anniversaries")))
       (:name "Backlog" :todo "BACKLOG")))

    ;; add space between dates by adding space after the final group
    (org-super-agenda-final-group-separator "\n"))
#+END_SRC

** Org-download
Allow drag-and-drop of images from browser, finder, etc.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-download "abo-abo/org-download"
    :after (org general)
    :custom (org-download-method 'directory)
    :init
    (aero-mode-leader-def
      :keymaps 'org-mode-map
      "ic" '(org-download-clipboard :wk "insert image from clipboard")))
#+END_SRC

** Functions for the org agenda

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-agenda-list ()
    "`org-agenda', skipping command menu to list."
    (interactive)
    (org-agenda nil "a"))

  (defun aero/org-class-agenda-list ()
    "`org-agenda', skipping command menu to list."
    (interactive)
    (org-agenda nil "s"))

  (defun aero/org-agenda-todo ()
    "`org-agenda', skipping command menu to todos."
    (interactive)
    (org-agenda nil "t"))

  (defun aero/org-agenda-new ()
    "Create a new task at the current agenda item."
    (interactive)
    (org-agenda-switch-to)
    (org-capture 0))

  (defun org-agenda-list-closed-on-last-workday ()
    (interactive)
    (let* ((org-agenda-files (list (buffer-file-name)
                                   (expand-file-name "archive/archive.org" aero/thornlog-path)
                                   (expand-file-name "log.org" aero/roam-path)))
           (today (current-time))
           (weekday (format-time-string "%u" today))
           (days-back (if (string= weekday "1") 3 1)) ; If today is Monday (1), go back 3 days to Friday
           (specific-day (format-time-string "%Y-%m-%d" (time-subtract today (days-to-time days-back))))
           (org-agenda-log-mode-items '(closed))
           (org-agenda-skip-deadline-if-done nil)
           (org-agenda-skip-scheduled-if-done nil)
           (org-agenda-skipp-timestamp-if-done nil)
           (org-super-agenda-groups '((:time-grid t))))
      (org-agenda-list nil specific-day 'day)))

  (defun insert-todays-timestamp-at-entry-end ()
    "Insert today's timestamp at the end of the current org entry."
    (interactive)
    (save-excursion
      (org-back-to-heading t)
      (end-of-line)
      (insert " ")
      (org-insert-time-stamp (current-time) nil)))
#+END_SRC

** Org-roam
A fantastic note-taking system, used for building a second brain.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! org-roam :auto
    :after (general org)
    :functions (org-roam-node-find
                org-roam-capture
                org-roam-node-insert
                org-roam-alias-add
                org-roam-refile)

    :custom
    (org-roam-directory (expand-file-name "roam" aero/thornlog-path))
    (org-roam-mode-sections
     (list #'org-roam-backlinks-section
           #'org-roam-reflinks-section
           #'org-roam-unlinked-references-section))

    (org-id-locations-file (expand-file-name ".org-id-locations" aero-cache-dir))

    (org-roam-capture-templates
     '(("d" "default" plain "%?"
        :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
        :immediate-finish t  ; skip capture buffer, just open the file
        :unnarrowed t)))

    (org-roam-node-display-template
     (concat "${title} " (propertize "${tags}" 'face 'org-tag)))

    :init
    (aero-leader-def
      "vf" 'org-roam-node-find
      "vF" 'org-roam-capture
      "vi" 'org-roam-node-insert
      "vc" '(org-id-get-create :wk "create org ID for node")
      "va" 'org-roam-alias-add
      "vr" 'org-roam-refile)

    :config
    (org-roam-db-autosync-mode))
#+END_SRC

*** Thornlog
This is a personal logging and note taking system, based on org-roam. It's evolved drastically over the years, from a bespoke system to a more generic org-roam setup. The functions here are for managing the thornlog system.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/thornlog-log ()
    "Personal persistent log."
    (interactive)
    (org-roam-node-visit (org-roam-node-from-title-or-alias "Work Log")))

  (defun aero/thornlog-todo ()
    "Personal todo list."
    (interactive)
    (org-roam-node-visit (org-roam-node-from-title-or-alias "Work Todo: Triaged Tasks and Inbox")))

  (defun aero/thornlog-clean-save ()
    "Automates the git commit in thornlog."
    (interactive)
    (let* ((default-directory aero/thornlog-path)
           (timestamp (format-time-string "%Y-%m-%d %H:%M")))
      (save-some-buffers t)
      (let ((todo-file (expand-file-name "todo.org" aero/roam-path)))
        (when (file-exists-p todo-file)
          (with-current-buffer (find-file-noselect todo-file)
            (aero/org-archive-cleanup)
            (save-some-buffers t))))
      (shell-command "git fetch origin")
      (if (not (zerop (shell-command "git rev-list --count @{u}..")))
          (user-error "Remote has changes, manual commit required")
        (progn
          (shell-command "git add -A")
          (shell-command (format "git commit -m '%s'" timestamp))
          (if (not (zerop (shell-command "git push origin")))
              (user-error "Git push failed, manual inspection required")
            (message "Done with Thornlog commit and push"))))))

  (defun aero/pull-thornlog ()
    "Pulls the latest changes from Thornlog."
    (interactive)
    (let ((default-directory aero/thornlog-path))
      (shell-command "git pull origin main")
      (message "Pulled latest changes from Thornlog")))

  (defun insert-meeting-task ()
    (interactive)
    (let* ((meeting-name (read-string "Meeting Name: "))
           (meeting-time (read-string "Meeting Time (optional): "))
           (today (format-time-string "%Y-%m-%d"))
           (scheduled-string (if (not (string= meeting-time ""))
                                 (format "<%s %s>" today meeting-time)
                               (format "<%s>" today)))
           (task-string (format "*** MEETING %s  :meeting:\nSCHEDULED: %s"
                                meeting-name scheduled-string)))
      (goto-char (point-max))
      (re-search-backward "^\\*+ Meetings" nil t)
      (org-end-of-subtree)
      (insert "\n\n" task-string)))

  (defun insert-new-day ()
    (interactive)
    (unless (string= (file-name-nondirectory (buffer-file-name)) "log.org")
      (user-error "Not in log.org file"))
    (goto-char (point-max))
    (yas-expand-snippet (yas-lookup-snippet "new-day")))

  (defun aero/org-add-file-tag ()
    "Prompts for a tag with completion from all org-roam tags and adds it to the file's tags, placing
  it after the #+title: line if it exists."
    (interactive)
    (let* ((case-fold-search t)
           (all-tags-query "SELECT DISTINCT tag FROM tags")
           (all-tags-result (org-roam-db-query all-tags-query))
           (all-tags (mapcar #'car all-tags-result))
           (tag (completing-read "Tag: " all-tags)))
      (save-excursion
        (goto-char (point-min))
        (if (re-search-forward "^#\\+filetags: \\(.*\\)$" nil t)
            (let ((existing-tags (match-string-no-properties 1)))
              (beginning-of-line)
              (delete-region (point) (line-end-position))
              (insert (format "#+filetags: %s%s:" existing-tags tag)))
          ;; No existing tags, search for title line to place new tags after
          (goto-char (point-min))
          (if (re-search-forward "^#\\+title:.*$" nil t)
              (progn
                (end-of-line)
                (insert (format "\n#+filetags: :%s:" tag)))
            (goto-char (point-min))
            (insert (format "#+filetags: :%s:\n" tag)))))))

  (defun aero/org-set-tags ()
    "Set tag on current entry or file."
    (interactive)
    (if (org-before-first-heading-p)
        (aero/org-add-file-tag)
      (org-set-tags-command)))

#+END_SRC


*** Update and created timestamps in Org-roam
This section appears as a blog post at https://jmthornton.net/blog/p/org-roam-created-modified-dates


It's useful to know when an org-roam node was created and when it's updated, so I automatically add a ~:created:~ property when visiting a node if it doesn't already exist, and a ~:modified:~ property when saving a node. This way, I can see when a note was created and when it was last modified. Note that the ~:created:~ property parses the timestamp from the filename and relies on Org-roam's default naming scheme. If you use a different naming scheme, you'll need to modify the ~org-roam-extract-timestamp-from-filepath~ function to match your scheme.

**** Automated creation date

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-roam-insert-created-property ()
    "Insert a :created: property for a new Org-roam node if it doesn't already have one."
    (interactive)
    (when (org-roam-file-p)
      (unless (org-entry-get (point-min) "created" t)
        (let ((creation-time (aero/org-roam-extract-timestamp-from-filepath
                              (buffer-file-name))))
          (when creation-time
            (save-excursion
              (goto-char (point-min))
              (org-set-property "created" creation-time)))))))
#+END_SRC

**** Extract timestamp from filename

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-roam-extract-timestamp-from-filepath (filepath)
    "Extract timestamp from the Org-roam FILEPATH assuming it follows the default naming scheme."
    (let ((filename (file-name-nondirectory filepath)))
      (when (string-match "\\([0-9]\\{8\\}\\)\\([0-9]\\{4\\}\\)" filename)
        (let ((year (substring filename (match-beginning 1) (+ (match-beginning 1) 4)))
              (month (substring filename (+ (match-beginning 1) 4) (+ (match-beginning 1) 6)))
              (day (substring filename (+ (match-beginning 1) 6) (+ (match-beginning 1) 8)))
              (hour (substring filename (match-beginning 2) (+ (match-beginning 2) 2)))
              (minute (substring filename (+ (match-beginning 2) 2) (+ (match-beginning 2) 4))))
          (let ((time-struct (date-to-time (format "%s-%s-%sT%s:%s" year month day hour minute))))
            (format-time-string "[%Y-%m-%d %a %H:%M]" time-struct))))))
#+END_SRC

**** Keeping modification dates current

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero/org-roam-insert-modified-property ()
    "Update the :modified: property for an Org-roam node upon saving."
    (when (org-roam-file-p)
      (save-excursion
        (goto-char (point-min))  ; Ensure property is applied to the whole file
        (org-set-property "modified" (format-time-string "[%Y-%m-%d %a %H:%M]")))))
#+END_SRC

**** Hooking it up

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'before-save-hook #'aero/org-roam-insert-created-property)
  (add-hook 'before-save-hook #'aero/org-roam-insert-modified-property)
#+END_SRC

*** Consult-org-roam
Provides a more powerful interface for searching org-roam nodes using ripgrep

#+BEGIN_SRC emacs-lisp :lexical t
  (package! consult-org-roam "jgru/consult-org-roam"
    :after (org-roam general)
    :custom
    (consult-org-roam-grep-func #'consult-ripgrep)
    :config
    (aero-leader-def
      "vb" 'consult-org-roam-backlinks
      "vB" 'consult-org-roam-backlinks-recursive
      "vl" 'consult-org-roam-forward-links
      "v'" 'consult-org-roam-search))
#+END_SRC

* Writing
** Writegood
Mark passive voice, duplicate words and weasel words

#+BEGIN_SRC emacs-lisp :lexical t
  (package! writegood-mode (:repo "bnbeckwith/writegood-mode")
    :hook ((text-mode) . writegood-mode))
#+END_SRC

** Eprime
Mark E′ violations

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eprime-mode (:host gitlab :repo "thornjad/eprime-mode" :branch "main")
    :after (general)
    :commands (eprime-check-buffer eprime-mode)
    :init
    (aero-leader-def
      "tp" 'eprime-check-buffer
      "tP" 'eprime-mode))
#+END_SRC

* Applications
** Pomp (pomodoro)
My pomodoro package

#+BEGIN_SRC emacs-lisp :lexical t
  (package! pomp (:host gitlab :repo "thornjad/pomp")
    :after (general evil)
    :commands (pomp)
    :custom
    (pomp-pomodoro-length 55)
    (pomp-short-break-length 10)
    (pomp-long-break-length 15)
    :init
    (aero-leader-def "ap" 'pomp))
#+END_SRC

** Restclient (HTTP requests)
A simple way to make HTTP requests from within Emacs

#+BEGIN_SRC emacs-lisp :lexical t
  (package! restclient :auto
    :after (general)
    :commands (restclient-mode)
    :mode ("\\.http\\'" . restclient-mode)
    :config
    (require 'general)
    (aero-mode-leader-def
      :keymaps 'restclient-mode-map
      "RET" '(restclient-http-send-current-stay-in-window :wk "Run query at point")
      "c" '(restclient-http-send-current :wk "Run query at point and focus")
      "r" '(restclient-http-send-current-raw :wk "Run query, no pretty print")
      "n" 'restclient-jump-next
      "p" 'restclient-jump-prev
      "." 'restclient-mark-current
      "y" 'restclient-copy-curl-command))
#+END_SRC

** ESUP
Emacs startup profiler.

The override of =esup-read-results= works around a bug where esup tries to profile cl-lib and fails by doing some nil checking.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! esup "jschaf/esup"
    :commands (esup)
    :config
    (defun esup-read-results ()
      "Read all `esup-result' objects from `esup-incoming-results-buffer'.

  HACKED by Aero to add nil checking."
      (let (results sep-end-point)
        (with-current-buffer (get-buffer esup-incoming-results-buffer)
          (goto-char esup-last-result-start-point)
          (message "at %s" esup-last-result-start-point)
          (unless (eobp)
            (while (setq sep-end-point (esup-next-separator-end-point))
              (when-let ((result (car (esup-read-result (point)))))
                (push result results))
              (setq esup-last-result-start-point sep-end-point)
              (goto-char esup-last-result-start-point))))
        (nreverse results))))
#+END_SRC

** Virtual-comment
An underrated package for temporary comments, really useful for debugging. The package doesn't define its own faces, using a variable instead, so we have to declare it.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! virtual-comment "thanhvg/emacs-virtual-comment"
    :hook ((virtual-comment-make-mode . evil-insert-state))
    :after (general evil)
    :commands (virtual-comment-make
               virtual-comment-next
               virtual-comment-previous
               virtual-comment-delete
               virtual-comment-paste
               virtual-comment-show)
    :custom (virtual-comment-face 'virtual-comment-face)
    :init
    (defface virtual-comment-face
      '((t :inherit highlight))
      "Face for virtual comments"
      :group 'virtual-comment)
    (aero-leader-def
      "v" '(:ignore t :wk "virtual comment")
      "vv" 'virtual-comment-make
      "vn" 'virtual-comment-next
      "vp" 'virtual-comment-previous
      "vk" 'virtual-comment-delete
      "vP" 'virtual-comment-paste
      "vs" 'virtual-comment-show))
#+END_SRC

* Prog modes
** Auto-mode settings
Set up some auto-mode settings for various file types. Files without extensions are assumed to be text files.

For some reason, makefile-mode doesn't always activate for Makefiles, so we add it here.

#+BEGIN_SRC emacs-lisp :lexical t
  (add-to-list 'auto-mode-alist '("/[^./]*\\'" . text-mode))
  (add-to-list 'auto-mode-alist '("\\(README\\|readme\\)\\'" . text-mode))
  (add-to-list 'auto-mode-alist '("/\\.dir-locals\\.el\\'" . emacs-lisp-mode))
  (add-to-list 'auto-mode-alist '("/Cask\\'" . emacs-lisp-mode))
  (add-to-list 'auto-mode-alist '("Makefile" . makefile-mode))
#+END_SRC

** C Language
#+BEGIN_SRC emacs-lisp :lexical t
  (package! cc-mode :builtin
    :mode (("\\.c\\'" . c-mode)
           ("\\.h\\'" . c-mode)
           ("\\.cpp\\'" . cpp-mode)
           ("\\.hpp\\'" . cpp-mode))
    :preface
    (defun aero/c-mode-common-hook ()
      "Hook to run in all C modes"
      (set (make-local-variable 'parens-require-spaces) nil))
    :hook (c-mode-common . aero/c-mode-common-hook))
#+END_SRC

** Sh-script

#+BEGIN_SRC emacs-lisp :lexical t
  (package! sh-script :builtin :defer t
    :mode ("\\.\\(sh\\|bash\\|zsh\\|zsh-theme\\)\\'" . sh-mode)
    :config
    (defun indent-paragraph ()
      (interactive)
      (save-excursion
        (mark-paragraph) (indent-region (region-beginning) (region-end)))))
#+END_SRC

** Markdown
We make an alteration to =markdown-mode-syntax-table= to teach it that quotes mean strings, regardless of what the mode's developer believes. We also ensure that checkboxes are not expanded by smartparens.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! markdown-mode "jrblevin/markdown-mode"
    :after (general smartparens)
    :mode (("\\.md\\'" . gfm-mode)
           ("\\.markdown\\'" . gfm-mode)
           ("github\\.com.*\\.txt\\'" . gfm-mode))
    :hook (markdown-mode . flyspell-mode)

    :custom
    (markdown-mode-syntax-table (make-syntax-table text-mode-syntax-table))
    (markdown-header-scaling t)
    (markdown-display-remote-images t)
    (markdown-header-scaling-values '(1.3 1.2 1.1 1.0 1.0 1.0))
    (markdown-enable-wiki-links t)
    (markdown-italic-underscore t)
    (markdown-make-gfm-checkboxes-buttons t)
    (markdown-gfm-additional-languages '("sh"))
    (markdown-fontify-code-blocks-natively t)

    :config
    (sp-local-pair 'gfm-mode "- [ " "]"))
#+END_SRC

*** Markdown-toc

#+BEGIN_SRC emacs-lisp :lexical t
  (package! markdown-toc (:repo "ardumont/markdown-toc")
    :commands (markdown-toc-generate-toc markdown-toc-refresh-toc))
#+END_SRC

** Yaml
#+BEGIN_SRC emacs-lisp :lexical t
  (package! yaml-mode (:repo "yoshiki/yaml-mode")
    :mode "\\.ya?ml\\'")
#+END_SRC

** Ocaml (Tuareg)
#+BEGIN_SRC emacs-lisp :lexical t
  (package! tuareg :auto :mode ("\\.mli?\\'" . tuareg-mode))
#+END_SRC

** Web mode (HTML, CSS, JS)
If we have tree-sitter, prefer tsx-ts-mode (which will also load eglot)

#+BEGIN_SRC emacs-lisp :lexical t
  (package! web-mode "fxbois/web-mode"
    :mode "\\.\\(jsp\\|tpl\\|php\\|xml\\|html?\\|erb\\|svg\\|mjs\\|jsx\\|s?css\\|astro\\)\\'"
    :custom (web-mode-enable-engine-detection t)
    :config
    (unless (treesitterp) (add-to-list 'auto-mode-alist '("\\.tsx\\'" . web-mode))))
#+END_SRC

*** Astro mode
We define a custom mode for Astro files, which is really just web mode. This allows us to set up Eglot to run the Astro LS on these files

#+BEGIN_SRC emacs-lisp :lexical t
  (define-derived-mode astro-mode web-mode "astro")
#+END_SRC

*** Emmet
Provides emmet expansion in web-mode

#+BEGIN_SRC emacs-lisp :lexical t
  (package! emmet-mode :auto
    :hook ((web-mode html-mode css-mode scss-mode js-mode) . emmet-mode)
    :init (setq emmet-self-closing-tag-style " /")
    :config
    (add-hook 'js-mode-hook (lambda () (setq emmet-expand-jsx-className? t))))
#+END_SRC

Ensure we expand className in JSX

#+BEGIN_SRC emacs-lisp :lexical t
  (eval-when-compile (defvar emmet-expand-jsx-className?))
  (add-hook 'js-mode-hook (lambda () (setq emmet-expand-jsx-className? t)))
#+END_SRC

** Jest
My own package for running Jest tests from within Emacs. Based loosely on the functionality in VS Code

#+BEGIN_SRC emacs-lisp :lexical t
  (package! jest "thornjad/emacs-jest"
    :commands (jest jest-file jest-test)
    :after (general))
#+END_SRC

** SQL

#+BEGIN_SRC emacs-lisp :lexical t
  (package! sql :builtin
    :defer t
    :after (general)
    :commands (sql-connect)
    :init
    (aero-leader-def
      "Sc" 'sql-connect)

    :config
    (setq sql-sqlite-program "sqlite3")

    (aero-mode-leader-def
      :keymaps 'sql-mode-map
      "b" 'sql-send-buffer
      "B" 'aero/sql-send-buffer-and-focus
      "r" 'sql-send-region
      "R" 'aero/sql-send-region-and-focus
      "p" 'sql-send-paragraph
      "P" 'aero/sql-send-paragraph-and-focus
      "s" 'sql-send-string
      "S" 'aero/sql-send-string-and-focus)

    ;; for sql comint
    (add-to-list 'same-window-buffer-names "*SQL: *")
    (add-hook 'sql-interactive-mode-hook #'evil-insert-state)

    (defun aero/sql-send-string-and-focus ()
      "Send a string to SQLi and switch to SQLi in `insert state'."
      (interactive)
      (let ((sql-pop-to-buffer-after-send-region t))
        (call-interactively 'sql-send-string)
        (evil-insert-state)))

    (defun aero/sql-send-buffer-and-focus ()
      "Send the buffer to SQLi and switch to SQLi in `insert state'."
      (interactive)
      (let ((sql-pop-to-buffer-after-send-region t))
        (sql-send-buffer)
        (evil-insert-state)))

    (defun aero/sql-send-paragraph-and-focus ()
      "Send the paragraph to SQLi and switch to SQLi in `insert state'."
      (interactive)
      (let ((sql-pop-to-buffer-after-send-region t))
        (sql-send-paragraph)
        (evil-insert-state)))

    (defun aero/sql-send-region-and-focus (start end)
      "Send region to SQLi and switch to SQLi in `insert state'."
      (interactive "r")
      (let ((sql-pop-to-buffer-after-send-region t))
        (sql-send-region start end)
        (evil-insert-state)))

    (defun my-sql-save-history-hook ()
      (let ((lval 'sql-input-ring-file-name)
            (rval 'sql-product))
        (if (symbol-value rval)
            (let ((filename
                   (concat "~/.emacs.d/sql/"
                           (symbol-name (symbol-value rval))
                           "-history.sql")))
              (set (make-local-variable lval) filename))
          (error
           (format "SQL history will not be saved because %s is nil"
                   (symbol-name rval))))))
    (add-hook 'sql-interactive-mode-hook 'my-sql-save-history-hook))
#+END_SRC

** Lisp editing environment
*** Common Lisp
#+BEGIN_SRC emacs-lisp :lexical t
  (package! common-lisp-mode :builtin
    :mode "\\(Lakefile|\\.\\(cl|lisp\\)\\)\\'")
#+END_SRC

**** Slime
A powerful Common Lisp environment. We load SBCL faster by using a preset socket and POSIX shit. Note that this requires some setup in the SBCL REPL:

#+BEGIN_SRC common-lisp :tangle no
  (mapc 'require '(sb-bsd-sockets sb-posix sb-introspect sb-cltl2 asdf))
  (save-lisp-and-die "sbcl.core-for-slime")
#+END_SRC

#+BEGIN_SRC emacs-lisp :lexical t
  (package! slime :auto
    :commands slime
    :init
    (setq-default
     inferior-lisp-program "ecl"
     slime-contribs '(slime-fancy))
    (defvar slime-lisp-implementations)
    (setq slime-lisp-implementations
          '((sbcl ("sbcl" "--core" "sbcl.core-for-slime"))
            (ecl ("ecl")))))
#+END_SRC

*** Redefine the Lisp indent function
#+BEGIN_SRC emacs-lisp :lexical t
  ;; redefined to turn this:
  ;; (:foo bar
  ;;       :spam ham)
  ;; into this:
  ;; (:foo bar
  ;;  :spam ham)
  (eval-after-load "lisp-mode"
    '(defun lisp-indent-function (indent-point state)
       "This function is the normal value of the variable `lisp-indent-function'.
    The function `calculate-lisp-indent' calls this to determine if the arguments of
    a Lisp function call should be indented specially. INDENT-POINT is the position
    at which the line being indented begins. Point is located at the point to indent
    under (for default indentation); STATE is the `parse-partial-sexp' state for
    that position. If the current line is in a call to a Lisp function that has a
    non-nil property `lisp-indent-function' (or the deprecated `lisp-indent-hook'),
    it specifies how to indent. The property value can be:

    - `defun', meaning indent `defun'-style \(this is also the case if there is no
      property and the function has a name that begins with \"def\", and three or
      more arguments);

    - an integer N, meaning indent the first N arguments specially (like ordinary
      function arguments), and then indent any further arguments like a body;

    - a function to call that returns the indentation (or nil).
      `lisp-indent-function' calls this function with the same two arguments that it
      itself received.

    This function returns either the indentation to use, or nil if the Lisp function
    does not specify a special indentation."
       (let ((normal-indent (current-column))
             (orig-point (point)))
         (goto-char (1+ (elt state 1)))
         (defvar calculate-lisp-indent-last-sexp)
         (parse-partial-sexp (point) calculate-lisp-indent-last-sexp 0 t)
         (cond
          ;; car of form doesn't seem to be a symbol, or is a keyword
          ((and (elt state 2)
                (or (not (looking-at "\\sw\\|\\s_"))
                    (looking-at ":")))
           (if (not (> (save-excursion (forward-line 1) (point))
                       calculate-lisp-indent-last-sexp))
               (progn (goto-char calculate-lisp-indent-last-sexp)
                      (beginning-of-line)
                      (parse-partial-sexp (point)
                                          calculate-lisp-indent-last-sexp 0 t)))
           ;; Indent under the list or under the first sexp on the same line as
           ;; calculate-lisp-indent-last-sexp. Note that first thing on that line
           ;; has to be complete sexp since we are inside the innermost containing
           ;; sexp.
           (backward-prefix-chars)
           (current-column))
          ((and (save-excursion
                  (goto-char indent-point)
                  (skip-syntax-forward " ")
                  (not (looking-at ":")))
                (save-excursion
                  (goto-char orig-point)
                  (looking-at ":")))
           (save-excursion
             (goto-char (+ 2 (elt state 1)))
             (current-column)))
          (t
           (let ((function (buffer-substring (point)
                                             (progn (forward-sexp 1) (point))))
                 method)
             (setq method (or (function-get (intern-soft function)
                                            'lisp-indent-function)
                              (get (intern-soft function) 'lisp-indent-hook)))
             (cond ((or (eq method 'defun)
                        (and (null method)
                             (> (length function) 3)
                             (string-match "\\`def" function)))
                    (lisp-indent-defform state indent-point))
                   ((integerp method)
                    (lisp-indent-specform method state
                                          indent-point normal-indent))
                   (method
                    (funcall method indent-point state)))))))))

  (add-hook 'emacs-lisp-mode-hook (lambda () (setq-local indent-tabs-mode nil)))
  (add-hook 'common-lisp-mode-hook (lambda () (setq-local indent-tabs-mode nil)))
  (add-hook 'lisp-mode-hook (lambda () (setq-local indent-tabs-mode nil)))
#+END_SRC

** Clojure
#+BEGIN_SRC emacs-lisp :lexical t
  (package! clojure-mode :auto :mode "\\.\\(cljs?\\|cljs.*\\|edn\\|boot\\)\\'")
#+END_SRC

*** Cider
A Clojure development environment

#+BEGIN_SRC emacs-lisp :lexical t
  (package! cider :auto
    :hook (clojure-mode . cider-mode)
    :after (clojure-mode general)
    :commands (cider
               cider-jack-in)
    :custom
    (cider-show-error-buffer t)
    (cider-repl-history-file (expand-file-name "cider-history" aero-cache-dir))
    :config
    (aero-mode-leader-def
      :keymaps '(clojure-mode-map cider-mode-map)
      "c" '(:ignore t :wk "cider")
      "c RET" 'cider-run

      "c'" 'cider-switch-to-repl-buffer
      "c," 'cider-pop-back
      "cQ" 'cider-quit
      "cl" '(:ignore t :wk "load")
      "clb" 'cider-load-buffer
      "clf" 'cider-load-file
      "cld" '(cider-load-all-files :wk "load directory")
      "cR" 'cider-ns-refresh
      "ch" '(:ignore t :wk "help")
      "chd" 'cider-doc
      "chj" 'cider-javadoc
      "chc" 'cider-clojuredocs
      "chC" 'cider-clojuredocs-web
      "cha" 'cider-apropos
      "chD" 'cider-apropos-documentation
      "ct" '(:ignore t :wk "test")
      "ctt" 'cider-test-run-test
      "ctr" 'cider-test-rerun-test
      "ctn" 'cider-test-run-ns-tests
      "ctp" 'cider-test-run-project-tests
      "ctf" 'cider-test-rerun-failed-tests
      "ctp" 'cider-test-show-report
      "cb" 'cider-load-buffer-and-switch-to-repl-buffer
      "cd" 'cider-eval-defun-at-point
      "cs" 'cider-eval-sexp-at-point
      "cr" 'cider-eval-region
      "cm" '(:ignore t :wk "macro expand")
      "cmm" 'cider-macroexpand-1
      "cma" 'cider-macroexpand-all
      "cN" 'cider-eval-ns-form
      "ce" '(:ignore t :wk "echo")
      "cee" '(cider-eval-last-sexp :wk "echo last sexp")
      "cer" '(cider-eval-last-sexp-to-repl :wk "eval last sexp to repl")
      "cep" '(cider-pprint-eval-last-sexp :wk "pprint last sexp")))
#+END_SRC

** Emacs Lisp
*** Package-lint
Linting for Emacs packages

#+BEGIN_SRC emacs-lisp :lexical t
  (package! package-lint "purcell/package-lint"
    :commands (package-lint-current-buffer))
#+END_SRC

*** Elisp-autofmt
Automatically format elisp code

#+BEGIN_SRC emacs-lisp :lexical t
  (package! elisp-autofmt :auto
    :commands (elisp-autofmt-buffer
               elisp-autofmt-region)
    :custom
    (elisp-autofmt-cache-directory
     (expand-file-name "elisp-autofmt-cache" aero-cache-dir)))
#+END_SRC

*** El2md
Convert elisp files to markdown Readme files

#+BEGIN_SRC emacs-lisp :lexical t
  (package! el2md (:host gitlab :repo "thornjad/el2md")
    :after (general)
    :commands (el2md-write-readme
               el2md-view-buffer
               el2md-write-file)
    :init
    (aero-mode-leader-def
      :keymaps 'emacs-lisp-mode-map
      "m" '(:ignore t :wk "el2md")
      "mr" 'el2md-write-readme
      "mv" 'el2md-view-buffer
      "mw" 'el2md-write-file))
#+END_SRC


** Python

#+BEGIN_SRC emacs-lisp :lexical t
  (package! python-mode :auto
    :after (general)
    :mode "\\.py\\'"
    :custom
    (python-indent-guess-indent-offset t)
    (python-indent-guess-indent-offset-verbose nil)
    :init
    (setq-default python-shell-interpreter "python3")
    (setq-default python-indent-offset 4)

    :config
    (defvar python-mode-initialized nil))
#+END_SRC

*** Elpy

#+BEGIN_SRC emacs-lisp :lexical t
  (package! elpy (:host github :repo "jorgenschaefer/elpy")
    :hook ((python-mode ein-mode) . elpy-mode)
    :custom
    (elpy-rpc-virtualenv-path 'default)
    (elpy-rpc-python-command "python3")
    (py-return-key #'py-newline-and-indent)

    :config
    (elpy-enable)
    (aero-mode-leader-def
      :keymaps 'elpy-mode-map
      "p" 'run-python
      "'" 'elpy-shell-switch-to-shell
      "s" '(:ignore t :wk "shell send")
      "ss" '(elpy-shell-send-region-or-buffer)
      "sS" '(elpy-shell-send-region-or-buffer-and-go)
      "sd" '(elpy-shell-send-defun)
      "sD" '(elpy-shell-send-defun-and-go)
      "sb" '(elpy-shell-send-buffer)
      "sB" '(elpy-shell-send-buffer-and-go)
      "sc" '(elpy-shell-send-defclass)
      "sC" '(elpy-shell-send-defclass-and-go)))
#+END_SRC

*** Flymake-mypy
Some type checking via Flymake. Must be added after eglot so eglot doesn't clobber it.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flymake-mypy "com4/flymake-mypy"
    :after (eglot flymake)
    :init
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (derived-mode-p 'python-base-mode)
                  (flymake-mypy-enable)))))
#+END_SRC

*** Flymake-ruff
Some type checking via Flymake. Must be added after eglot so eglot doesn't clobber it.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flymake-ruff "erickgnavar/flymake-ruff"
    :after (eglot flymake)
    :functions (flymake-ruff-load)
    :init
    (with-eval-after-load 'eglot
      (add-hook 'eglot-managed-mode-hook
                (lambda ()
                  (when (derived-mode-p 'python-base-mode)
                    (setq python-flymake-command '("ruff" "--quiet" "--stdin-filename=stdin" "-"))
                    (flymake-ruff-load))))))
#+END_SRC

** Rust
#+BEGIN_SRC emacs-lisp :lexical t
  (package! rust-mode :auto
    :mode "\\.rs\\'"
    :config
    (setenv "PATH" (concat "~/.cargo/bin:" (getenv "PATH")))
    (require 'company)
    (defvar company-tooltip-align-annotations)
    (declare-function company-indent-or-complete-common "company")
    (setq company-tooltip-align-annotations t)
    (define-key rust-mode-map (kbd "TAB") #'company-indent-or-complete-common)
    (add-hook 'rust-mode-hook
              (lambda () (setq indent-tabs-mode t))))
#+END_SRC

*** Cargo
#+BEGIN_SRC emacs-lisp :lexical t
  (package! cargo :auto
    :commands cargo-minor-mode
    :hook (rust-mode . cargo-minor-mode))
#+END_SRC

** TOML
#+BEGIN_SRC emacs-lisp :lexical t
  (package! toml-mode :auto
    :mode "\\(\\.toml\\|Cargo\\.lock\\)\\'")
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp :lexical t
  (package! docker-compose-mode :auto :mode "docker-compose.*\.yml\\'")
  (package! dockerfile-mode :auto :mode "Dockerfile[a-zA-Z.-]*\\'")
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp :lexical t
  (package! lua-mode :auto :mode "\\.lua\\'")
#+END_SRC

** AppleScript
#+BEGIN_SRC emacs-lisp :lexical t
  (package! applescript-mode :auto :mode "\\.applescript\\'")
#+END_SRC

** Nhexl
Provides a hexl-mode with a better interface, for viewing and editing binary files.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! nhexl-mode :auto :defer t)
#+END_SRC

** Terraform

#+BEGIN_SRC emacs-lisp :lexical t
  (package! terraform-mode :auto :mode "\\.tf\\'")
#+END_SRC

** GraphQL

#+BEGIN_SRC emacs-lisp :lexical t
  (package! graphql-mode :auto :mode "\\.graphql\\'")
#+END_SRC

** Groovy
#+BEGIN_SRC emacs-lisp :lexical t
  (package! groovy-mode :auto :mode "\\(\\.groovy\\'\\|Jenkinsfile\\)")
#+END_SRC

** CSV
#+BEGIN_SRC emacs-lisp :lexical t
  (package! csv-mode :auto :mode "\\.csv\\'")
#+END_SRC

** Orson (WIP)

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook
   'orson-mode-hook
   (lambda ()
     (setq-local indent-tabs-mode nil)
     (prettify-symbols-mode nil)))
#+END_SRC

** Elm
This mode should eanble elm-indent-mode by default, but for some reason it stopped doing this on Dec 21, 2022. Probably caused this myself, but the =:hook= fixes it.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! elm-mode :auto :hook (elm-mode . elm-indent-mode))
#+END_SRC

** TCL
The greatest tool command language

#+BEGIN_SRC emacs-lisp :lexical t
  (package! tcl :builtin
    :mode ("\\(\\.tcl\\|\\.test\\)\\'" . tcl-mode)
    :custom
    (tcl-application "tclsh")
    :config
    (add-to-list 'tcl-type-alist '("namespace" "eval" tcl-expr tcl-commands)))
#+END_SRC

** Rivet
My own Rivet mode, which is a TCL extension for Apache

#+BEGIN_SRC emacs-lisp :lexical t
  (package! rivet-mode "thornjad/rivet-mode")
#+END_SRC

* Parentheses
** Smartparens
Provides a better way of handling parentheses.

My =aero/smart-closing-parenthesis= is based on a similar function in Spacemacs.

We also set up a bunch of paren pairs that aren't default for some reason.

Toward the end we set up parens with post-handlers to add an extra newline and indent when hitting RET inside them.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! smartparens "Fuco1/smartparens"
    :after (general) :defer 5
    :functions (show-smartparens-global-mode
                sp-kill-sexp sp-local-pair
                sp-local-pairs sp-pair
                sp-up-sexp)
    :after (evil general)
    :hook ((after-init . smartparens-global-mode))

    :init
    (setq sp-show-pair-from-inside t)
    (smartparens-global-mode +1)

    :config
    (defun aero/smart-closing-parenthesis ()
      "Insert a closing pair delimiter or move point past existing delimiter.

  If the expression at point is already balanced and there is a closing delimiter
  for that expression on the current line, move point forward past the closing
  delimiter. If the expression is balanced but there is no closing delimiter on
  the current line, insert a literal ')' character. If the expression is not
  balanced, insert a closing delimiter for the current expression. This command
  uses Smartparens navigation commands and therefore recognizes pair delimiters
  that have been defined using `sp-pair' or `sp-local-pair'."
      (interactive)
      (let* ((sp-navigate-close-if-unbalanced t)
             (current-pos (point))
             (current-line (line-number-at-pos current-pos))
             next-pos next-line)
        (aero/voidvar! sp-navigate-close-if-unbalanced)
        (save-excursion
          (let ((buffer-undo-list)
                (modified (buffer-modified-p)))
            (unwind-protect
                (progn
                  (sp-up-sexp)
                  (setq next-pos (point)
                        next-line (line-number-at-pos)))
              (primitive-undo (length buffer-undo-list)
                              buffer-undo-list)
              (set-buffer-modified-p modified))))
        (cond
         ((and (= current-line next-line)
               (not (= current-pos next-pos)))
          (sp-up-sexp))
         (t
          (insert-char ?\))))))

    (require 'smartparens-config)
    (show-smartparens-global-mode t)

    (defun aero/copy-sexp-as-kill (&optional arg)
      "Copy the sexp to the kill ring without killing."
      (interactive)
      (funcall #'sp-kill-sexp arg t))

    (defun aero/sp-wrap-double-quote () (interactive) (sp-wrap-with-pair "\""))
    (defun aero/sp-wrap-single-quote () (interactive) (sp-wrap-with-pair "'"))
    (defun aero/sp-wrap-backtick () (interactive) (sp-wrap-with-pair "`"))
    (defun aero/sp-wrap-angle () (interactive) (sp-wrap-with-pair "<"))

    (general-define-key
     :states '(normal visual)
     :prefix "SPC"
     "s^" '(sp-beginning-of-sexp :which-key "beginning of sexp")
     "s$" '(sp-end-of-sexp :which-key "end of sexp")
     "sh" '(sp-backward-sexp :which-key "back")
     "sl" '(sp-forward-sexp :which-key "forward")
     "sw" '(:ignore t :which-key "wrap")
     "sw(" 'sp-wrap-round
     "sw{" 'sp-wrap-curly
     "sw[" 'sp-wrap-square
     "sw<" 'aero/sp-wrap-angle
     "sw\"" '(aero/sp-wrap-double-quote :wk "wrap double quote")
     "sw'" '(aero/sp-wrap-single-quote :wk "wrap single quote")
     "sw`" '(aero/sp-wrap-backtick :wk "wrap backtick")
     "swr" 'sp-rewrap-sexp
     "su" '(sp-unwrap-sexp :which-key "unwrap")
     "sk" '(sp-kill-sexp :which-key "kill")
     "sK" '(aero/copy-sexp-as-kill :wk "copy as kill"))

    (sp-local-pair 'web-mode "<?" "?>")
    (sp-local-pair 'web-mode "{" "}")
    (sp-local-pair 'web-mode "{ " " }")
    (sp-local-pair 'web-mode "{%" "%}")
    (sp-local-pair 'web-mode "{% " " %}")
    (sp-local-pair 'web-mode "{{ " " }}")
    (sp-local-pair 'web-mode "`" "`")
    (sp-local-pair 'org-mode "$" "$")
    (sp-local-pair 'org-mode "=" "=")
    (sp-local-pair 'org-mode "/" "/" :trigger-wrap "/" )
    (sp-local-pair 'markdown-mode "```" "```" :post-handlers '(:add ("||\n[i]" "RET")))

    (sp-pair "{" "}" :post-handlers '(:add ("||\n[i]" "RET")))
    (sp-pair "[" "]" :post-handlers '(:add ("||\n[i]" "RET")))
    (sp-pair "(" ")" :post-handlers '(:add ("||\n[i]" "RET")))

    (define-key evil-insert-state-map ")" 'aero/smart-closing-parenthesis))
#+END_SRC

** Rainbow delimiters
Colorize parens to make it easier to see where they start and end.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! rainbow-delimiters "Fanael/rainbow-delimiters"
    :hook ((prog-mode . rainbow-delimiters-mode)))
#+END_SRC

* Flymake & Flyspell
** Flymake
Diagnostics, errors, warnings, etc. This is a faster version of Flycheck.

For fringe indicators, left is the default, but since git-gutter also uses left we need to make sure it still makes the same choice. If they conflict, one of them wins and it works out fine.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flymake :builtin
    :after (general)
    :custom
    (flymake-fringe-indicator-position 'left-fringe)
    (flymake-wrap-around t)
    (flymake-no-changes-timeout 0.6)

    :config
    ;; Buffer diagnostics in bottom window
    (add-to-list 'display-buffer-alist
                 '("\\*Flymake diagnostics for.*"
                   (display-buffer-reuse-window display-buffer-in-side-window)
                   (side . bottom)
                   (window-height . 23)))

    (aero-leader-def
      "en" 'flymake-goto-next-error
      "ep" 'flymake-goto-prev-error
      "eb" 'flymake-show-buffer-diagnostics))
#+END_SRC

*** Flymake-diagnostic-at-point
Makes flymake diagnostics appear in a popup

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flymake-diagnostic-at-point (:repo "meqif/flymake-diagnostic-at-point")
    :after flymake
    :hook (flymake-mode . flymake-diagnostic-at-point-mode))
#+END_SRC

*** Flymake-eslint
Flymake for ESLint. Must be added after eglot so eglot doesn't clobber it.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flymake-eslint "orzechowskid/flymake-eslint"
    :after (eglot)
    :init
    (add-hook 'eglot-managed-mode-hook
              (lambda ()
                (when (and (derived-mode-p '(typescript-mode typescript-ts-mode js-mode web-mode))
                           (not (derived-mode-p 'json-mode))
                           (executable-find "eslint"))
                  (flymake-eslint-enable)))))
#+END_SRC

** Flyspell
Spell checking, using a custom dictionary. Skips code blocks in org-mode.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flyspell :builtin
    :after (general)
    :hook ((prog-mode . flyspell-prog-mode)
           (text-mode . flyspell-mode))
    :config
    (defvar aero-etc-dir)
    (setq
     flyspell-issue-message-flag nil
     ispell-personal-dictionary (expand-file-name "ispell/personal_dictionary.aws" aero/thornlog-path)
     flyspell-sort-corrections nil)

    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_SRC" . "#\\+END_SRC"))
    (add-to-list 'ispell-skip-region-alist '("#\\+BEGIN_EXAMPLE" . "#\\+END_EXAMPLE"))

    (aero-leader-def
      "psP" 'flyspell-prog-mode
      "psN" 'flyspell-goto-next-error
      "psw" 'flyspell-word
      "psb" 'flyspell-buffer
      "psr" 'flyspell-region))
#+END_SRC

*** Flyspell-lazy
Lazy flyspell mode, which only checks words when they're idle.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flyspell-lazy (:repo "rolandwalker/flyspell-lazy")
    :hook ((flyspell-mode . flyspell-lazy-mode)))
#+END_SRC

*** Flyspell-correct
A better interface for correcting spelling

#+BEGIN_SRC emacs-lisp :lexical t
  (package! flyspell-correct "d12frosted/flyspell-correct"
    :after (general flyspell)
    :config
    (aero-leader-def
      "psc" 'flyspell-correct-wrapper
      "psC" 'flyspell-correct-at-point
      "psp" 'flyspell-correct-previous
      "psn" 'flyspell-correct-next))
#+END_SRC

* Formatting (Apheleia)
It's hard to remember what this package is called, which is a marker of a bad name. However, it's good code, handling auto-formatting on save.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! apheleia
    (:repo "radian-software/apheleia"
     :files (:defaults ("scripts" "scripts/formatters")))
    :after general
    :init (apheleia-global-mode +1)
    :config
    (dolist (cmd `((elm-format . (npx "elm-format" "--yes" "--stdin"))
                   (cljfmt . ("lein" "cljfmt" "fix" filepath))))
      (add-to-list 'apheleia-formatters cmd))

    (add-to-list 'apheleia-mode-alist '(clojure-mode . cljfmt))

    (aero-leader-def
      "bI" 'apheleia-format-buffer))
#+END_SRC

* Debugging with Dape
Package for the debug adapter protocol. See https://github.com/svaante/dape for setup instructions, there's a fair bit of manual system setup required to actually use this.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! dape "svaante/dape"
    :after (general project eglot)
    :custom
    (dape-buffer-window-arrangement 'right)
    (dape-adapter-dir (expand-file-name "debug-adapters/" user-emacs-directory))
    (dape-inlay-hints t)
    :config
    ;; Save buffers on startup, useful for interpreted languages
    (add-hook 'dape-on-start-hooks (lambda () (save-some-buffers t t)))

    (setq dape-configs-port 4711)

    (defun aero/install-vscode-js-debug ()
      "Run installation procedure to install JS debugging support"
      (interactive)
      (let ((vscode-js-debug-dir (expand-file-name "js-debug" dape-adapter-dir)))
        (mkdir vscode-js-debug-dir t)
        (let ((default-directory (expand-file-name vscode-js-debug-dir)))
          (vc-git-clone "https://github.com/microsoft/vscode-js-debug.git" "." nil)
          (message "git repository created")
          (call-process "npm" nil "*aero-install*" t "install")
          (message "npm dependencies installed")
          (call-process "npx" nil "*aero-install*" t "gulp" "dapDebugServer")
          (message "vscode-js-debug installed"))))

    ;; Set up JS
    (add-to-list 'dape-configs
                 `(js-debug-node
                   modes (js-mode js-ts-mode typescript-mode typescript-ts-mode)
                   ;; Command to start the debug adapter
                   command "node"
                   command-cwd ,(concat dape-adapter-dir "js-debug")
                   command-args ("src/dapDebugServer.js" ,(format "%d" dape-configs-port))
                   ;; Port that Emacs will connect to the debug adapter
                   port ,dape-configs-port
                   ;; Debug configuration
                   :type "pwa-node"
                   :request "attach"
                   :name "Attach to Jest Test"
                   :address "localhost"
                   :port 9229 ;; Node.js debug port (from --inspect-brk)
                   :localRoot dape-cwd-fn
                   :remoteRoot nil
                   :skipFiles ["<node_internals>/**" "**/node_modules/**"]
                   :resolveSourceMapLocations ["!**/node_modules/**" "**/*"]
                   :suppressSourceMapWarning t
                   )))
#+END_SRC

* Whitespace and indentation
WS-Butler removes trailing whitespace, but only in modes where it's not important. This is a good default, but we need to exempt some modes where whitespace is important.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! ws-butler :auto
    :functions (ws-butler-global-mode)
    :init (ws-butler-global-mode)
    :custom
    (ws-butler-global-exempt-modes '(special-mode comint-mode term-mode eshell-mode)))
#+END_SRC

* EWW: the Emacs Web Wowser
A basic builtin browser. Very lightweight. Uses shr, which is a simple HTML renderer.

First some helper functions for shr that make it render block-level elements as paragraphs, set the buffer title, and set up some interactive functions.

#+BEGIN_SRC emacs-lisp :lexical t
  (defmacro shr-display-block (tag)
    "Register TAG a paragraph (in CSS parlance \"display:block;\").

  See https://developer.mozilla.org/en-US/docs/Glossary/Block-level_content"
    (let ((fname
           (intern (format "shr-tag-%s" tag)))
          (docstring
           (format "Render \"%s\" tag as paragraph." tag)))
      `(defun ,fname (dom)
         ,docstring
         (shr-ensure-paragraph)
         (shr-generic dom)
         (shr-ensure-paragraph))))

  (defun aero/set-eww-buffer-title ()
    "Rename eww mode buffer so the title of the page is displayed, making
       fake-tabbed-browsing easier"
    (let ((title (plist-get eww-data :title)))
      (when (eq major-mode 'eww-mode)
        (if title
            (rename-buffer (concat "eww - " title) t)
          (rename-buffer "eww" t)))))

  (defun aero/wiki-news () (interactive)
         (eww-browse-url "https://en.wikipedia.org/wiki/Portal:Current_events"))

  (defun aero/xwidgets-search-ddg (&optional term)
    (interactive "sSearch DuckDuckGo: ")
    (xwidget-webkit-browse-url (format "https://duckduckgo.com/?q=%s" (or term "")) t))

  (defun aero/ace-link-eww-new-buffer ()
    "Call `ace-link-eww' but open in a new buffer.

  This simply calls `ace-link-eww' with a fake double prefix, which is equivalent to the list containing 16."
    (interactive)
    (ace-link-eww '(16)))
#+END_SRC

Then the actual EWW config. We open almost everything from Emacs into EWW, except a few sites that are so JS-heavy that they don't work at all.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eww :builtin
    :after (general evil ace-link)
    :commands (eww eww-browse-url eww-search-words browse-url-at-point)
    :hook ((eww-mode . visual-line-mode)
           (eww-after-render . aero/set-eww-buffer-title))

    :custom
    (browse-url-browser-function
     '((".*google.*maps.*" . browse-url-generic)
       ("docs.google.com" . browse-url-generic)
       ("*.atlassian.com" . browse-url-generic)
       ("*.atlassian.net" . browse-url-generic)
       ("github.com" . browse-url-generic)
       ("gitlab.com" . browse-url-generic)
       ("melpa.org" . browse-url-generic)
       ("zoom.us" . browse-url-generic)
       ("t.co" . browse-url-generic)
       ("twitter.com" . browse-url-generic)
       ("youtube.com" . browse-url-generic)
       ("*.reddit.com" . browse-url-generic)
       ("." . eww-browse-url)))

    ;; MacOS needs its hand held to find the binary
    (browse-url-generic-program (if (system-is-mac)
                                    "/Applications/Firefox Developer Edition.app/Contents/MacOS/firefox"
                                  "firefox"))

    (eww-search-prefix "https://lite.duckduckgo.com/lite?q=")
    (shr-max-width 90)
    (shr-indentation 2)
    (url-privacy-level 'high) ; don't send email nor last location

    :init
    (aero-leader-def "wbn" '(aero/wiki-news :wk "wikipedia news"))

    :config
    (evil-define-key 'normal eww-mode-map
      "SPC SPC" 'execute-extended-command
      "?" 'describe-mode
      "^" 'eww-up-url
      "u" 'eww-up-url
      "U" 'eww-top-url
      (kbd "<backspace>") 'eww-back-url
      "H" 'eww-back-url
      "L" 'eww-forward-url
      "&" 'eww-browse-with-external-browser
      "D" 'eww-download
      "o" 'eww
      "O" 'eww-open-in-new-buffer
      "p" 'pocket-reader-eww-add-link
      "P" 'aero/pocket-add-current-url
      "f" 'ace-link-eww
      "F" 'aero/ace-link-eww-new-buffer
      "m" 'eww-add-bookmark
      "R" 'eww-readable
      "r" 'eww-reload
      "gr" 'eww-reload
      "J" 'eww-buffer-show-next
      "K" 'eww-buffer-show-previous
      "T" 'eww-open-in-new-buffer
      "W" 'eww-copy-page-url
      "q" 'kill-current-buffer
      "Q" 'quit-window
      "go" 'eww
      "gf" 'eww-view-source
      "gc" 'url-cookie-list
      "gh" 'eww-list-histories
      "gb" 'eww-list-buffers
      "gt" 'eww-list-buffers)

    ;; viewing history
    (evil-set-initial-state 'eww-history-mode 'normal)
    (evil-define-key 'normal eww-history-mode-map
      (kbd "RET") 'eww-history-browse
      "q" 'quit-window)

    ;; viewing buffers
    (evil-set-initial-state 'eww-buffers-mode 'normal)
    (evil-define-key 'normal eww-buffers-mode-map
      "D" 'eww-buffer-kill
      (kbd "RET") 'eww-buffer-select
      "q" 'quit-window)

    ;; Handle display block elements
    (shr-display-block "article")
    (shr-display-block "aside")
    (shr-display-block "footer")
    (shr-display-block "header")
    (shr-display-block "nav")
    (shr-display-block "section")

    ;; bookmarks
    (evil-set-initial-state 'eww-bookmark-mode 'normal)
    (evil-define-key 'normal eww-bookmark-mode-map
      "D" 'eww-bookmark-kill
      "P" 'eww-bookmark-yank
      (kbd "RET") 'eww-bookmark-browse
      "q" 'quit-window))
#+END_SRC

** Shrface
Adds some org-like features to EWW

#+BEGIN_SRC emacs-lisp :lexical t
  (package! shrface (:host github :repo "chenyanming/shrface")
    :defer t
    :after (eww)
    :hook (eww-after-render . shrface-mode)
    :custom (shrface-href-versatile t)
    :config
    (shrface-basic)
    (shrface-trial)
    (shrface-default-keybindings))
#+END_SRC

** Shr-tag-pre-highlight
Syntax highlighting for HTML pre tags

#+BEGIN_SRC emacs-lisp :lexical t
  (package! shr-tag-pre-highlight "xuchunyang/shr-tag-pre-highlight.el"
    :after (shr)
    :config
    (add-to-list 'shr-external-rendering-functions '(pre . shr-tag-pre-highlight)))
#+END_SRC

* Devdocs
An interface for semi-offline documentation.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! devdocs "astoff/devdocs.el"
    :after (general)
    :commands (devdocs-lookup)
    :custom (devdocs-data-dir (expand-file-name "devdocs" aero-cache-dir))
    :init
    (aero-leader-def "hD" 'devdocs-lookup)
    (add-hook 'python-mode-hook (lambda () (setq-local devdocs-current-docs '("python~3.12"))))
    (add-hook 'python-ts-mode-hook (lambda () (setq-local devdocs-current-docs '("python~3.12"))))
    (add-hook 'typescript-mode-hook (lambda ()
                                      (setq-local devdocs-current-docs
                                                  '("typescript" "rxjs" "angular" "javascript"))))
    (add-hook 'ng2-ts-mode-hook (lambda ()
                                  (setq-local devdocs-current-docs
                                              '("typescript" "angular" "rxjs" "javascript" "html"))))
    (add-hook 'web-mode-hook (lambda ()
                               (setq-local devdocs-current-docs
                                           '("angular" "rxjs" "javascript" "html"))))
    (add-hook 'clojure-mode-hook (lambda ()
                                   (setq-local devdocs-current-docs
                                               '("clojure~1.11")))))
#+END_SRC

* Elfeed
Simple RSS reader

#+BEGIN_SRC emacs-lisp :lexical t
  (package! elfeed "skeeto/elfeed"
    :commands (elfeed elfeed-db-compact)
    :after (general evil)
    :custom
    (elfeed-search-title-max-width 120)
    (elfeed-db-directory aero/thornlog-elfeed-directory)
    (elfeed-search-filter "+unread")
    (elfeed-sort-order 'ascending)
    :config
    (evil-set-initial-state 'elfeed-search-mode 'normal)
    (evil-set-initial-state 'elfeed-show-mode 'normal))
#+END_SRC

** Elfeed-org
Allows managing feeds in an org file

#+BEGIN_SRC emacs-lisp :lexical t
  (defun aero-elfeed-org ()
    "Set `elfeed-feeds' from the org file."
    (interactive)
    (require 'org-element)
    (setq elfeed-feeds
          (with-temp-buffer
            (insert-file-contents aero/thornlog-elfeed-org-file)
            (org-mode)
            (let (links)
              (org-element-map (org-element-parse-buffer) 'link
                (lambda (element)
                  (let ((raw-link (org-element-property :raw-link element))
                        tags)

                    ;; Traverse up the tree to collect tags from parent headlines
                    (while (setq element (org-element-property :parent element))
                      (when (eq (org-element-type element) 'headline)
                        (let ((headline-tags (org-element-property :tags element)))
                          (when headline-tags
                            (setq tags (append tags (mapcar 'intern headline-tags)))))))
                    (when-let ((feed-title (org-entry-get element "feed_title")))
                      (setf (elfeed-meta (elfeed-db-get-feed raw-link) :title) feed-title))
                    (push (if tags (cons raw-link tags) raw-link) links))))
              links)))
    (elfeed-log 'info "aero-elfeed-org loaded %i feeds" (length elfeed-feeds)))

  ;; Run once when elfeed loads up
  (with-eval-after-load 'elfeed
    (aero-elfeed-org))
#+END_SRC

* AI
** Gptel
Generic interface to a variety of LLMs.

We do register Claude as a valid backend, but it's not a default because I've found it to hallucinate a lot more than GPT (as of 2024).

We also try defining a pair of simple tools, but this is experimental.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! gptel "karthink/gptel"
    :after (general)
    :commands (gptel gptel-send gptel-menu)
    :custom
    (gptel-api-key openai-api-key)
    (gptel-model 'o1) ; default model when starting a buffer
    (gptel-use-header-line t)
    (gptel-display-buffer-action '(pop-to-buffer-same-window)) ; chat in same window
    (gptel-prompt-prefix-alist '((markdown-mode . "\n### ")
                                 (org-mode . "-----\n*** ")
                                 (text-mode . "------\n### ")))
    (gptel-response-prefix-alist '((markdown-mode . "\n")
                                   (org-mode . "-----\n")
                                   (text-mode . "------\n")))
    (gptel-directives
     '((default
         . "You are a large language model living in Emacs and a helpful, competent assistant. You do
         not have feelings and you do not apologize for anything. The user is a senior software
         engineer with limited time; you treat the user's time as precious, but you are not afraid to
         ask for clarification when needed. Respond concisely and cite sources for factual claims.
         NEVER explain code unless asked to do so, the explanation is a waste of time unless you are
         instructed to provide it. Do not add explanations or descriptions unless asked. Use
         Github-flavored Markdown for code snippets. When using Python, assume the user is using
         version 3.9 or newer. When using Typescript, assume the user is using version 4.8 or newer.
         When using SQL, use lowercase keywords. Do no use LaTeX.")
       (programming
        . "You are a large language model and a careful, competent programmer. Provide code and only
        code as output without any additional text, prompt or note.")
       (writing . "You are a large language model and a writing assistant. Respond concisely.")
       (chat . "You are a large language model and a conversation partner. Respond concisely.")))

    :init
    (aero-leader-def
      "aic" 'gptel
      "ais" '(gptel-send :wk "send region or buffer to point")
      "aim" 'gptel-menu)

    (defun aero/gptel-send-buffer ()
      "If in gptel buffer, goto end and call gptel-send."
      (interactive)
      (when gptel-mode
        (save-excursion
          (goto-char (point-max))
          (call-interactively 'gptel-send))))

    (general-define-key
     :keymaps 'gptel-mode-map
     (kbd "C-<return>") 'aero/gptel-send-buffer)

    :config
    (when (and (boundp 'anthropic-api-key) anthropic-api-key)
      (gptel-make-anthropic "Claude" :stream t :key anthropic-api-key))

    (when (and (boundp 'kagi-api-key) kagi-api-key)
      (gptel-make-kagi "Kagi" :key kagi-api-key))

    (gptel-make-tool
     :name "read_buffer"
     :function (lambda (buffer)
                 (unless (buffer-live-p (get-buffer buffer))
                   (error "error: buffer %s is not live." buffer))
                 (with-current-buffer  buffer
                   (buffer-substring-no-properties (point-min) (point-max))))
     :description "return the contents of an emacs buffer"
     :args (list '(:name "buffer"
                   :type string
                   :description "the name of the buffer whose contents are to be retrieved"))
     :category "emacs")

    (gptel-make-tool
     :name "create_file"
     :function (lambda (path filename content)
                 (let ((full-path (expand-file-name filename path)))
                   (with-temp-buffer
                     (insert content)
                     (write-file full-path))
                   (format "Created file %s in %s" filename path)))
     :description "Create a new file with the specified content"
     :args (list '(:name "path"
  	               :type string
  	               :description "The directory where to create the file")
                 '(:name "filename"
  	               :type string
  	               :description "The name of the file to create")
                 '(:name "content"
  	               :type string
  	               :description "The content to write to the file"))
     :category "filesystem"))
#+END_SRC

** Copilot
A connection with Microsoft GitHub Copilot. Works best with company-box, so we consider it a requirement. The idle delay is longer than default so it doesn't mess with typing.

Enabled in all programming modes. I've tried automatically enabling in org-mode as well, but copilot doesn't handle prose very well.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! copilot (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
    :after (company-box general)
    :hook (prog-mode . copilot-mode)
    :custom (copilot-idle-delay 0.2)
    :bind (:map copilot-mode-map
           ("C-<tab>" . copilot-accept-completion)
           ("C-c C-i" . copilot-accept-completion)
           ("C-c C-n" . copilot-next-completion)
           ("C-c C-p" . copilot-previous-completion)))
#+END_SRC

* Shell
** Xterm-color
Colorize shell output

#+BEGIN_SRC emacs-lisp :lexical t
  (package! xterm-color :auto
    :commands (xterm-color-filter)
    :init
    (setq compilation-environment '("TERM=xterm-256color"))
    (defun aero/advice-compilation-filter (f proc string)
      (funcall f proc (xterm-color-filter string)))
    (advice-add 'compilation-filter :around #'aero/advice-compilation-filter))
#+END_SRC

** Eshell
Realistically this is my main shell. It does try to override some important bindings by default, so we undo that.

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eshell :builtin
    :after (general evil)
    :commands eshell
    :defines (evil-move-cursor-back
              eshell-save-history-on-exit
              eshell-history-size
              eshell-glob-case-insensitive
              eshell-ls-initial-args
              eshell-cmpl-dir-ignore
              eshell-visual-commands
              eshell-visual-subcommands)
    :functions (eshell-previous-input
                eshell-next-input)
    :config
    (define-key eshell-mode-map (kbd "M-h") #'windmove-left)
    (define-key eshell-mode-map (kbd "M-l") #'windmove-right)
    (define-key eshell-mode-map (kbd "M-p") #'eshell-previous-input)
    (define-key eshell-mode-map (kbd "M-n") #'eshell-next-input)
    (define-key eshell-mode-map (kbd "M-r") #'consult-history)

    (setq
     eshell-save-history-on-exit t
     eshell-buffer-maximum-lines 12000
     eshell-glob-case-insensitive t
     eshell-aliases-file (expand-file-name "eshell-alias" aero-etc-dir)
     eshell-history-size 350
     eshell-ls-initial-args "-lah"
     eshell-cmpl-dir-ignore "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\)/\\'"
     eshell-visual-commands '("vi" "screen" "top" "less" "more" "lynx"
                              "ncftp" "pine" "tin" "trn" "elm" "vim"
                              "nmtui" "alsamixer" "htop" "el" "elinks"
                              "ssh" "nethack" "dtop" "dstat" "docker-compose")
     eshell-visual-subcommands '(("git" "log" "diff" "show"))
     eshell-cmpl-cycle-completions nil ; tab cycles the completion list
     eshell-buffer-maximum-lines 12000 ; auto truncate after 12k lines
     eshell-history-size 500 ; history size
     eshell-buffer-shorthand t ; buffer shorthand -> echo foo > #'buffer
     eshell-plain-echo-behavior t ; treat 'echo' like shell echo
     eshell-banner-message '(format "%s %s\n"
                                    (propertize (format " %s " (string-trim (buffer-name)))
                                                'face 'mode-line-highlight)
                                    (propertize (current-time-string)
                                                'face 'font-lock-keyword-face))
     eshell-scroll-to-bottom-on-input 'all
     eshell-kill-processes-on-exit t
     eshell-hist-ignoredups t
     eshell-error-if-no-glob t  ; mimics zsh behavior
     completion-ignore-case t)

    ;; Enable autopairing in eshell
    (add-hook 'eshell-mode-hook #'smartparens-mode)

    ;; Try to load in PATH
    (let ((default-directory (expand-file-name "~")))
      (setq eshell-path-env (getenv "PATH")))

    ;; doesn't handle less too well
    ;; (setenv "PAGER" "cat")
    (setenv "PAGER" "bat")
    (setenv "TERM" "xterm-256color")

    ;; Remove hscroll-margin in shells, otherwise you get jumpiness when the
    ;; cursor comes close to the left/right edges of the window.
    (add-hook 'eshell-mode-hook
              (lambda () (setq-local hscroll-margin 0
                                     evil-move-cursor-back nil)))

    ;; Use tab to cycle completions
    (add-hook 'eshell-mode-hook (lambda () (setq-local pcomplete-cycle-completions nil)))

    (defalias 'eshell/emacs 'find-file)

    (defun eshell/e (pattern)
      (if (stringp pattern)
          (find-file pattern)
        (mapc #'find-file (mapcar #'expand-file-name pattern))))

    (defun eshell/rmdanglingdockers ()
      (let ((dangling-images (shell-command-to-string "docker images -f \"dangling=true\" -q")))
        (if (string-empty-p dangling-images)
            (message "No dangling images found.")
          (eshell-command (concat "docker rmi " dangling-images)))))

    (defun eshell/dockerkillorphans ()
      (let ((orphan-volumes (shell-command-to-string "docker volume ls -qf dangling=true")))
        (if (string-empty-p orphan-volumes)
            (message "No orphan volumes found.")
          (eshell-command (concat "docker volume rm " orphan-volumes)))))

    (defun eshell/dockercleanup ()
      (eshell/dockerkillorphans)
      (eshell/rmdanglingdockers))

    ;; So the history vars are defined
    (require 'em-hist)
    (when (boundp 'eshell-save-history-on-exit)
      ;; Don't ask, just save
      (setq eshell-save-history-on-exit t))

    (eval-after-load 'esh-opt
      '(progn
         (require 'em-cmpl)
         (require 'em-prompt)
         (require 'em-term))))
#+END_SRC

*** Eshell-prompt-extras
Adds a more informative prompt to eshell

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eshell-prompt-extras "zwild/eshell-prompt-extras"
    :after (eshell)
    :config
    (with-eval-after-load "esh-opt"
      (autoload 'epe-theme-multiline-with-status "eshell-prompt-extras")
      (setq eshell-highlight-prompt nil
            eshell-prompt-function 'epe-theme-multiline-with-status)))
#+END_SRC

*** Eshell-syntax-highlighting
Syntax highlighting in eshell

#+BEGIN_SRC emacs-lisp :lexical t
  (package! eshell-syntax-highlighting "akreisher/eshell-syntax-highlighting"
    :after eshell-mode
    :hook (eshell-mode . eshell-syntax-highlighting-mode))
#+END_SRC

*** Capf-autosuggest
Provides overlay suggestions in eshell. Use M-f to insert the next suggested word

#+BEGIN_SRC emacs-lisp :lexical t
  (package! capf-autosuggest "emacs-straight/capf-autosuggest"
    :hook (eshell-mode . capf-autosuggest-mode))
#+END_SRC

* Yarn-lock derived mode
Rather than loading in a whole package, creating a derived mode for Yarn Locks is so simple that I just do it here.

#+BEGIN_SRC emacs-lisp :lexical t
  (defvar yarn-lock-mode-syntax-table
    (let ((syntable (make-syntax-table)))
      (modify-syntax-entry ?# "<" syntable)
      (modify-syntax-entry ?\n ">" syntable)
      (modify-syntax-entry ?\" "\"" syntable)
      syntable))

  (defvar yarn-lock-mode-package-re "\\(^\\|,\\s-\\)\\([a-zA-Z-_0-9]+\\)@")
  (defvar yarn-lock-mode-dependencies-re "\\s-\\{4,\\}\\([a-zA-Z-_0-9]+\\)\\s-")
  (defvar yarn-lock-mode-attributes-re
    (regexp-opt '("version" "resolved" "dependencies" "integrity")))
  (defvar yarn-lock-mode-font-lock-defaults
    `((,yarn-lock-mode-attributes-re . '((t :inherit font-lock-builtin-face)))
      (,yarn-lock-mode-package-re . (2 '((t :inherit bold)) t)) ;; Direct deps
      (,yarn-lock-mode-dependencies-re . (1 '((t :inherit bold)) t)) ;; Dep of another dep (nested)
      ))
  (define-derived-mode yarn-lock-mode text-mode "Yarn Lock"
    "Simple mode for yarn.lock."
    :syntax-table yarn-lock-mode-syntax-table
    (setq font-lock-defaults '(yarn-lock-mode-font-lock-defaults)
          buffer-read-only t))
#+END_SRC

* General variable configuration
This is loaded toward the end so that it overrides other packages. This solves some occasional issues where a mode overrides indenting, for example.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq-default
   ;; general
   ring-bell-function 'ignore ; supprime cette putain de cloche.
   use-dialog-box nil ; use minibuffer to ask questions instead
   use-short-answers t ; y-or-n instead of yes-or-no
   sentence-end-double-space nil ; the world will not go to shit today
   default-fill-column 100 ; i am mortal, not Arthur Whitney
   fill-column 100
   help-window-select t ; focus help window when opened
   help-clean-buttons t ; remove quotes from buttons (why isn't this the default)
   kill-ring-max 5000 ; truncate kill ring after 5000 entries
   mark-ring-max 5000 ; truncate mark ring after 5000 entries
   kill-do-not-save-duplicates t ; don't add duplicate strings to kill-ring
   apropos-do-all t ; apropos is apropos
   global-display-line-numbers-mode nil ; fuck line numbers
   gnutls-min-prime-bits 4096 ; 256 est absurde
   confirm-kill-emacs 'yes-or-no-p ; too easy to kill when looking for alt file
   switch-to-buffer-preserve-window-point t ; try to preserve point position in closed buffers
   next-error-message-highlight t
   line-move-visual t ; move lines by display, not reality
   make-pointer-invisible t ; le curseur est une chienne
   auto-revert-interval 10 ; wait just a little longer (default is 5)
   pop-up-windows nil ; make new window for pop-ups
   window-sides-slots '(0 1 1 1) ; side-window slots (left top right bottom)
   shared-game-score-directory (expand-file-name "game-scores/" aero-etc-dir)
   idle-update-delay 0.5 ; default is 0.5
   bidi-paragraph-direction 'left-to-right ; no need to check
   bidi-inhibit-bpa t ; don't look for bidi paren balancing
   create-lockfiles nil ; tries to solve a non-existent problem and causes trouble doing it
   jit-lock-defer-time 0 ; wait to fontify until input ends, but no longer
   ns-use-srgb-colorspace nil ;; REVIEW what is this?
   show-paren-context-when-offscreen t ; for some langs, show context in echo area
   mail-user-agent nil ; disable email click opening mail message; error instead
   context-menu-mode t ; enable context menu when clicked, should be default
   isearch-forward t ; ensures evil repeats searches in the correct direction
   debugger-stack-frame-as-list t ; more readable Elisp stack traces
   enable-recursive-minibuffers t ; allow minibuffer commands in the minibuffer

   ;; Do not allow the cursor in the minibuffer prompt
   minibuffer-prompt-properties '(read-only t cursor-intangible t face minibuffer-prompt)

   ;; Emacs should just have code that automatically sets this threshold according to some function
   ;; involving a constant, the current date, and Moore's Law.
   large-file-warning-threshold 500000000

   ;; Defaults:
   ;; '("gnutls-cli --insecure -p %p %h"
   ;;   "gnutls-cli --insecure -p %p %h --protocols ssl3"
   ;;   "openssl s_client -connect %h:%p -no_ssl2 -ign_eof")
   tls-program '("gnutls-cli -p %p %h"
                 "openssl s_client -connect %h:%p -no_ssl2 -no_ssl3 -ign_eof")

   ;; Scrolling
   ;; Emacs spends too much effort recentering the screen if you scroll the
   ;; cursor more than N lines past window edges (where N is the settings of
   ;; `scroll-conservatively'). This is especially slow in larger files
   ;; during large-scale scrolling commands. If kept over 100, the window is
   ;; never automatically re-centered.
   scroll-conservatively 101
   scroll-margin 3 ; keep 3 lines at top and bottom of buffer when scrolling
   scroll-preserve-screen-position t ; see variable documentation; this is the modern expectation
   mouse-wheel-scroll-amount '(3 ((shift) . 1)) ; make scroll wheel scroll more at a time
   pixel-resolution-fine-flag 1 ; use pixel scrolling
   hscroll-margin 5 ; like scroll-margin but horizontal
   hscroll-step 1 ; on horizontal scroll, scroll by one column at a time
   ;; Reduce cursor lag by a tiny bit by not auto-adjusting `window-vscroll'
   ;; for tall lines. Thanks to Sacha Chua for the time saved!
   auto-window-vscroll nil
   mouse-wheel-progressive-speed nil ; don't accelerate TODO may not want this?
   comint-scroll-to-bottom-on-input t ; insert at bottom
   comint-scroll-to-bottom-on-output nil ; don't scroll on output by default
   comint-input-ignoredups t ; ignore duplicate inputs in history
   comint-prompt-read-only nil ; breaks shell-command sometimes

   compilation-scroll-output t ; scroll with compilation output
   compilation-max-output-line-length nil ; don't collapse long lines in compilation

   eww-search-prefix "https://lite.duckduckgo.com/lite?q=" ; eww search DuckDuckGo
   dictionary-server "dict.org" ; skip trying to search localhost

   ;; simple frame title; I find the default distracting
   frame-title-format '("Emacs — "
                        (:eval (if (buffer-file-name)
                                   (abbreviate-file-name (buffer-file-name))
                                 "%b"))
                        (:eval (when (and (buffer-modified-p) (not buffer-read-only))
                                 " •")))
   ns-use-proxy-icon nil ; remove icon from frame title in NS

   initial-scratch-message (concat ";; Welcome to GNU Emacs v" emacs-version
                                   "." (number-to-string emacs-build-number)
                                   "\n;;\n"
                                   ";; Go placidly amid the noise and haste,\n"
                                   ";; and remember what peace there may be in silence.\n"
                                   ";;\n"
                                   ";; Booted in " (emacs-init-time "%.3f seconds")
                                   (format " with %d garbage collections" gcs-done)
                                   (when (boundp 'straight--profile-cache)
                                     (format "\n;; Initialized %d packages"
                                             (+ (hash-table-size straight--profile-cache)
                                                (if (bound-and-true-p package-alist)
                                                    (length package-activated-list)
                                                  0))))
                                   "\n\n")

   use-package-verbose nil ; ignore verbose output from use-package

   ;; Save backups to system temp (somewhere in /var on MacOS)
   backup-directory-alist `((".*" . ,temporary-file-directory))
   auto-save-file-name-transforms `((".*" ,temporary-file-directory t))
   backup-by-copying t ; don't clobber symlinks, our file is what we want
   kept-new-versions 6 ; how many backups to keep
   kept-old-versions 2 ; keep first two versions forever
   delete-old-versions t ; delete backups older than `kept-new-versions' except `kept-old-versions'
   version-control t ; use version numbers in backup files

   git-commit-fill-column 72 ; best length in my opinion
   auto-save-file-name-transforms '((".*" "~/.config/emacs/auto-save-list/" t))
   save-interprogram-paste-before-kill t ; see variable documentation
   diff-switches "-u" ; unified diff by default

   ;; files
   confirm-nonexistent-file-or-buffer nil ; don't ask to create a buffer
   require-final-newline t ; add newline to end of files if there isn't one
   load-prefer-newer t ; load the newer of equivalent el, elc, eln
   completion-ignore-case t ; ignorer la capitalisation
   read-file-name-completion-ignore-case t ; ignorer la capitalisation des fichiers
   delete-auto-save-files t ; auto-delete auto-save auto-files automatically
   vc-follow-symlinks t ; don't ask to follow symlinks

   world-clock-list '(("America/New_York" "Home")
                      ("America/Los_Angeles" "San Francisco")
                      ("Europe/Warsaw" "Poland")
                      ("Europe/Amsterdam" "Netherlands")
                      ("Europe/London" "London")
                      ("America/Chicago" "Texas")
                      ("America/Denver" "Utah")
                      ("America/Denver" "Colorado")
                      ("Pacific/Auckland" "New Zealand")
                      ("Australia/Sydney" "Sydney"))

   world-clock-time-format "%R %Z (%z) %a %d %b "

   ;; xref
   ;; Use separate xref history for each window, allowing independent code navigation
   xref-history-storage #'xref-window-local-history

   ;; indentation
   indent-tabs-mode nil
   tab-width 2
   c-basic-offset 2
   cperl-indent-level 2
   css-indent-offset 2
   evil-shift-width 2
   js-indent-level 2
   js-switch-indent-offset 2
   js-syntactic-mode-name nil ; just use normal mode name
   js2-basic-offset 2
   typescript-indent-level 2
   python-indent-offset 4 ; 2 would be too much of a hassle
   rust-indent-offset 4
   sgml-basic-offset 2
   sh-basic-offset 2
   tcl-indent-level 2
   tcl-tab-always-indent t
   lua-indent-level 2
   groovy-indent-offset 2
   web-mode-attr-indent-offset 2
   web-mode-code-indent-offset 2
   web-mode-css-indent-offset 2
   web-mode-markup-indent-offset 2
   tab-stop-list (number-sequence 2 200 2))
#+END_SRC

Ensure language is setup, it's kind of crazy that this is necessary after all these years.

#+BEGIN_SRC emacs-lisp :lexical t
  (setenv "LANG" "en_US.UTF-8")
  (setenv "LC_ALL" "en_US.UTF-8")
#+END_SRC

Underscores delineate words.

#+BEGIN_SRC emacs-lisp :lexical t
  (modify-syntax-entry ?_ "w")
#+END_SRC

Ensure case statements indent properly.

#+BEGIN_SRC emacs-lisp :lexical t
  (with-eval-after-load 'prog-mode
    (c-set-offset 'case-label '++))
#+END_SRC

Show trailing whitespace in prog modes

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'prog-mode-hook (lambda () (setq show-trailing-whitespace t)))
#+END_SRC

Enable narrow to region without asking

#+BEGIN_SRC emacs-lisp :lexical t
  (put 'narrow-to-region 'disabled nil)
#+END_SRC

Prevent savehist from hogging the CPU

#+BEGIN_SRC emacs-lisp :lexical t
  (setq history-length 100)
  (put 'minibuffer-history 'history-length 50)
  (put 'evil-ex-history 'history-length 50)
  (put 'kill-ring 'history-length 25)
#+END_SRC

Try to get emacsclient to open frames with focus. Doesn't always work, especially in GNOME.

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'server-switch-hook (lambda () (select-frame-set-input-focus (selected-frame))))
#+END_SRC

Enable the mouse in TTY, just for scrolling really.

#+BEGIN_SRC emacs-lisp :lexical t
  (unless (display-graphic-p)
    (xterm-mouse-mode 1)
    (global-set-key (kbd "<mouse-4>") 'scroll-down-line)
    (global-set-key (kbd "<mouse-5>") 'scroll-up-line))
#+END_SRC

Disable idiotic Super keybindings. These are defined in =ns-win.el=. In my view, Super should be the domain of the OS and nothing in Emacs should ever be bound to it.

#+BEGIN_SRC emacs-lisp :lexical t
  (global-unset-key (kbd "s-:"))
  (global-unset-key (kbd "s-C"))
  (global-unset-key (kbd "s-D"))
  (global-unset-key (kbd "s-E"))
  (global-unset-key (kbd "s-F"))
  (global-unset-key (kbd "s-d"))
  (global-unset-key (kbd "s-e"))
  (global-unset-key (kbd "s-f"))
  (global-unset-key (kbd "s-g"))
  (global-unset-key (kbd "s-j"))
  (global-unset-key (kbd "s-k"))
  (global-unset-key (kbd "s-l"))
  (global-unset-key (kbd "s-m"))
  (global-unset-key (kbd "s-n"))
  (global-unset-key (kbd "s-o"))
  (global-unset-key (kbd "s-q"))
  (global-unset-key (kbd "s-t"))
  (global-unset-key (kbd "s-u"))
  (global-unset-key (kbd "s-w"))
#+END_SRC

Typing gets rid of the active region.

#+BEGIN_SRC emacs-lisp :lexical t
  (delete-selection-mode t)
#+END_SRC

Try to save point position between sessions. Doesn't work consistently, but it's not a huge deal.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq save-place-file (expand-file-name "saveplace" aero-etc-dir))
  (save-place-mode 1)
#+END_SRC

Ensure buffer names are unique when filenames match. The forward option will expand each duplicate buffer name to include their parent directories as far as necessary to make them unique. Does not apply to renamed buffers.

#+BEGIN_SRC emacs-lisp :lexical t
  (require 'uniquify)
  (setq uniquify-buffer-name-style 'forward)
#+END_SRC

Basic startup message override.

#+BEGIN_SRC emacs-lisp :lexical t
  (defun display-startup-echo-area-message ()
    "Override ridiculous built-in crap."
    (message "Aero est prêt"))
#+END_SRC

Put Eshell in bottom side window

#+BEGIN_SRC emacs-lisp :lexical t
  (add-to-list 'display-buffer-alist
               '("e?shell\\*\\(?:<[[:digit:]]+>\\)?\\'"
                 (display-buffer-reuse-window display-buffer-in-side-window)
                 (side . bottom)
                 (window-height . 23)))
#+END_SRC

If we leave a buffer, set its mark as inactive. Helps prevent accidentally following a mark to another file.

#+BEGIN_SRC emacs-lisp :lexical t
  (transient-mark-mode 1)
#+END_SRC

Word navigation within camelCase

#+BEGIN_SRC emacs-lisp :lexical t
  (global-subword-mode 1)
#+END_SRC

Don't allow the cursor in the minibuffer

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+END_SRC

Make files executable if the first line has a shebang

#+BEGIN_SRC emacs-lisp :lexical t
  (add-hook 'after-save-hook 'executable-make-buffer-file-executable-if-script-p)
#+END_SRC

Always always always wrap lines

#+BEGIN_SRC emacs-lisp :lexical t
  (global-visual-line-mode +1)
#+END_SRC

Log warnings but don't pop them up.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq warning-minimum-level :error)
#+END_SRC

** Disable custom system
I strongly prefer setting up customization with this very config file, so make sure nothing happens if I accidentally customize a variable. This will add the customization line to =/dev/null= instead of =init.el=.

#+BEGIN_SRC emacs-lisp :lexical t
  (setq-default custom-file "/dev/null")
#+END_SRC

* Idle garbage collection
Do garbage collection when I'm not actively doing anything for seven seconds.

#+BEGIN_SRC emacs-lisp :lexical t
  (run-with-idle-timer 7 t 'garbage-collect)
#+END_SRC

* Load local file
Load a local init file if it exists. This is a great place to put secrets and keys, or machine-specific functions such as helpers that rely on proprietary code structure or information.

#+BEGIN_SRC emacs-lisp :lexical t
  (load (expand-file-name "init.local" user-emacs-directory) t t)
#+END_SRC

#  LocalWords:  Editorconfig Savehist
